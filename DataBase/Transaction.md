## 트랜잭션
  ```
    데이터를 단순히 파일에 저장해도되는데 DB에 저장하는 이유는 뭘까?
    -> DB는 트랜잭션 개념을 제공하기 때문이다.

    트랜잭션은 이름그대로 번역하면 거래라는 의미이다.


    데이터베이스의 관점에서 트랜잭션은 말 그대로 데이터베이스의 하나의 거래를 안전하게 처리되도록 보장해주는것을 말한다.
    * 하나의 거래를 안전하게 처리하려면 생각보다 고려해야할점이 많다.

    ex) 은행 계좌에 이체를 할 경우 A계좌에 금액이 감소하고 B계좌에 금액이 증가해야 거래 처리가 완료됐다고 할 수 있다.


    `모든 작업이 성공하여 데이터베이스에 정상반영되는것을 커밋(Commit), 실패하여 이전상태로 돌아가는것을 롤백(Rollback)이라고 한다.`
  ```
#  
##
### 트랜잭션의 속성
  - 트랜잭션은 ACID를 보장해야한다.
  ```
    A(Atomicity) 원자성 : 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인양 모두 성공하거나 모두 실패해야한다.

    C(Consistency) 일관성 : 모든 트랜잭션은 항상 일관성있는 데이터베이스 상태를 유지해야한다.
        예를들어, 데이터베이스에서 정한 무결성 제약조건을 항상 만족해야한다.

    I(Isolation) 격리성 : 동시에 실행되는 트랜잭션들은 서로에게 영향을 미치지않도록 격리된다.
        예를들어, 같은 데이터를 수정할 수 없도록 해야한다. 격리성은 동시성과 관련된 성능이슈로 트랜잭션의 격리수준을 설정할 수 있다.

    D(Durability) 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야한다. 시스템이 중간에 문제가 발생해도 데이터베이스의 성공한 트랜잭션 로그로 복구가 가능해야한다.
  ```
#  
#  
  - 트랜잭션의 격리성과 격리수준
  ```
    트랜잭션은 원자성, 일관성, 지속성을 보장한다.

    문제는 격리성인데, 격리성을 완전히 보장하려면 트랜잭션을 거의 순서대로 실행해야한다.
    하지만 이렇게 할 경우 동시 처리 성능이 매우 나빠진다.


    `이런 문제로 ANSI 표준은 트랜잭션의 격리수준을 4단계로 나누어 정의한다.`


    트랜잭션의 4단계 격리수준 (Isolation Level)
      - Read Uncommited(커밋되지않은 읽기)
      - Read commited(커밋된 읽기)  // 주로 많이 사용
      - Repeatable Read(반복적 읽기) // 주로 많이 사용
      - Serializable(직렬화 가능) 
    
  ```
#  
#  
## 데이터베이스 연결 구조와 DB 세션
  - <img width="648" alt="스크린샷 2023-06-16 오후 9 14 17" src="https://github.com/pnci1029/TIL/assets/81909140/db71da66-d17e-4fef-b39b-4543baf701c6">
  ```

    1. 사용자는 WAS(ex) 톰캣)를 사용하여 DB접근 툴(ex) H2 console)과 같은 클라이언트를 사용하여 DB 서버에 접근이 가능하다.

    2. 클라이언트는 DB 서버에 요청을 보내고, 요청을 정상적으로 받은 DB 서버는 서버 내부에 세션을 만든다.

    3. 클라이언트로부터 커넥션을 통해 온 요청은 모두 세션을 통해 처리된다.
        ~~> 개발자 코드 작성 => 클라이언트를 통해 SQL 요청 => 커넥션에 연결된 세션이 SQL 처리 => 세션은 트랜잭션 실행 => 성공 혹은 실패로 커밋 혹은 롤백을 통해 트랜잭션 종료
    
    * 커넥션 풀이 커넥션을 열개를 생성하면, 세션도 열개가 생성된다.
  ```
  - <img width="678" alt="스크린샷 2023-06-16 오후 9 22 04" src="https://github.com/pnci1029/TIL/assets/81909140/d3f08fd5-d8e2-4a1b-9718-958d87263036">
#  
#  
#  
### 트랜잭션과 커밋
  ```
  자동커밋
    데이터베이스 종류에 따라 다르지만 보통 자동커밋 상태로 되어있다.
    - set autocommit true

    insert into member(member_id, money) values (member1, 10000);
    insert into member(member_id, money) values (member2, 20000);

  수동커밋
    수동커밋 모드를 실행하는것을 보통 트랜잭션의 시작으로 간주한다.
    - set autocommit false;

    insert into member(member_id, money) values (member1, 10000);
    insert into member(member_id, money) values (member2, 20000);
    commint / rollback

  반드시 쿼리 실행 후 커밋이나 롤백 명령어 호출
  수동커밋모드에서 커밋이나 롤백을 호출하지 않으면 db에 타임아웃 설정에 따라 임시저장된 작업이 사라진다.
  ```
#  
#  
#  
### DB 락
  - <img width="657" alt="스크린샷 2023-06-19 오후 9 52 25" src="https://github.com/pnci1029/TIL/assets/81909140/3688272e-8315-4082-a345-de96f84fe4b2">
  ```
    세션 1이 커밋이 되지않은 데이터를 수정하는 동안 세션 2가 같은 데이터를 수정하게되면 원자성이 깨져 문제점이 발생한다.
    여기에 세션1이 도중에 롤백을 하게되면 세션2는 잘못된 데이터를 수정하게된다.

    이런 문제를 방지하기위해 세션이 트랜잭션을 시작하게되면, 해당 세션이 커밋이나 롤백을 하기 전에 다른 세션이 수정을 할 수 없게 막아야한다.

    락(Lock)이라는 개념으로 해당 문제를 해결
  ```
  - db 락 처리과정
  - <img width="653" alt="스크린샷 2023-06-19 오후 9 58 51" src="https://github.com/pnci1029/TIL/assets/81909140/85a722a9-65e3-4065-b156-db65d8d4dea9">
  ```
    1. 세션 1이 트랜잭션 시작

    2. 세션 2도 트랜잭션 시작

    3. 세션 1이 데이터 수정 시도 (락 획득) (세션 2보다 먼저 수정 요청)

    4. 세션 2는 락을 획득하지 못하여 락을 획득할때까지 대기
      - 무한정 대기하지않고 설정된 락 타임아웃 시점까지 대기

    5. 세션 1이 락을 획득했으므로 update 쿼리 수행

    6. 세션 1 커밋 수행. 트랜잭션 종료 후 락 반납

    7. 세션 2가 락을 획득 후 5번 6번 수행

  ```










  
