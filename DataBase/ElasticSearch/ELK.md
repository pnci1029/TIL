# Chapter 1
#  
## 엘라스틱서치: 분산 검색엔진
  ```
    엘라스틱 서치는 검색엔진이지만 일반적인 네이버, 구글같은 검색포털과는 다르다.

    검색엔진은 내부적으로 각 도큐먼트를 엔덱싱하고 빠르게 검색하는데 사용하는 기술로, 네이버나 구글같은 검색 포털은 해당 검색엔진을 사용하여 만들게된다.

    엘라스틱 서치는 모든 레코드를 JSON 형태로 관리하고, 요청된 쿼리에 일치하는 결과값만 반환한다.
    엘라스틱 서치는 텍스트나 도큐먼트의 경우, 인덱싱 시점에 분석을 거쳐 용어 단위로 분해되고 역인덱스 사전을 구축한다.

    이렇게 최적화된 자료구조들을 바탕으로 병렬처리나 분산처리를 할 수 있다.

  ```
#  
  `검색엔진`
  ```
    엘라스틱 서치가 다른 관계형 DB나 다른 NoSQL DB에 비해 빠른 검색과 집계 성능을 실형하는 이유는, 검색엔진이면서 DB이기 때문이다.

    엘라스틱서치는 몽고디비와 같은 도큐먼트 형태의 NoSQL이지만, 검색과 성능이라는 측면에서 가장 크게 구별된다.

    특히 검색엔진으로써 가장 큰 특징중 하나는 스코어링, 즉 연관도에 따른 정렬이다.

    단순히 필드값을 기준으로 한 정렬은 어떤 종류의 데이터베이스에서도 제공되지만,
    엘라스틱 서치는 다양한 스코어링 방법을 포함하여 사용자가 정렬방식을 직접 정의할 수 있다.
  ```
#  
  - ![es_01](https://github.com/pnci1029/TIL/assets/81909140/25461efe-c96b-447b-9010-97f1759df8c7)
  `분산 시스템`
  ```
    엘라스틱 서치는 분산시스템으로서 복수의 인스턴스를 병렬로 배치하고 분산처리를 하여,
    검색속도를 무한히 확장 할 수 있게 했다.

    또한 노드간 복제 기능을 통해 일부 노드가 다운되더라도 정상적으로 서비스를 지숙가능하게 해준다.
    무엇보다 RestApi를 통해 프로그래밍 언어와 무관하게 사용자가 직접 접근할 수 있도록 활용성이 높다.

  ```
#  
  `단점` 
  ```
    그러나 저장공간이 크게 압축되지 않고 시스템 리소스를 많이사용하는 단점도 있다.

    그리고 DSL 쿼리를 사용하는데, JOIN코리가 어렵기 떄문에 사실상 반정규화를 기본으로 모델링해야한다.

    또한 인덱스가 불변의 자료구조이기때문에 도큐먼트를 수정하거나 사용할 경우 비용이 저렴하지않다.

    이러한 단점들은 검색 성능을 끌어올리기위해 트레이드오프가 이뤄진것으로,
    대량의 데이터를 처리할 때는 일반적으로 용인되는 제약이다.

    결과적으로 대용량 데이터에 대한 빠른 검색과 집계가 필요할 경우 고려해야하는 데이터베이스라고 할 수 있다.
  ```
#  
  -![키바나](https://github.com/pnci1029/TIL/assets/81909140/ea92a404-6818-4dcf-9254-7b90714f4774)
  `키바나`
  ```
    엘라스틱 서치가 RestApi가 잘 설계되었지만 복잡한 요청을 일일이 작성하기엔 불편함이 있다.

    키바나는 이런 불편함을 해소시켜주고 일종의 엘라스틱서치의 UI역할을 담당한다.

    엘라스틱 서치의 대부분의 관리기능, API콘솔, 모니터링 페이지등이 키바나에 포함된다.


    무엇보다 큰 특징은 시각화 대시보드이다.
    일반적으로 여러 차트나 그래프등의 시각도구들을 쉽게 구성하게해주고,
    이런 기능들이 엘라스틱서치의 대중화와 확산에 큰 공헌을 했다.
  ```
#  
  `로그스태시`
  ```
    로그스태시는 이벤트 수집과 정제를 위한 도구이다.

    대량의 데이터를 검색하기 위해 가장 먼저 선행돼아 할 작업은 데이터를 적재하는것이다.

    이는 빅데이터를 다룰 때 가장 손이 많은 작업이며, 엘라스틱 서치의 데이터 수집과 가공 기능은 로그스태시를 사용한다.
  ```
# Chapter 2
#  
  ```
  
  ```
# Chapter 3
## 엘라스틱 서치 기본
  ```
    처음 새로운 시스템을 접하게되면 두가지 난간에 부딪힌다.
    시스템을 알기위해서는 용어와 개념이 필요하다.

    새로 접한 시스템에서 용어와 개념은 머리에 들어오지않고, 결과적으로 시스템을 이해하기 어렵다.

    직접 검색엔진을 구축해본 경험이 없는 이상

    엘라스틱 서치 역시 마찬가지다.
  ```
  ```
    엘라스틱 서치를 제대로 활용하기 위해서는

    저장과 인출방식을 확실해 이해해야한다.

    1. 인출을 위해서는 가장먼저 저장이 필요하다.

    2. 저장을 하기위해서는 스키마를 구성하고 데이터를 집어넣어야한다.

    3. 이 과정에서 데이터 타입을 배우고 검색 내부 동작을 이해한다.
  ```
### 엘라스틱 서치 API 활용
#### 시스템 상태 확인
  - <img width="1661" alt="스크린샷 2023-07-19 오후 10 42 10" src="https://github.com/pnci1029/TIL/assets/81909140/0e9434d4-19fb-4012-8c37-f7fa7b9640b8">
  ```
    키바나 콘솔을 통해 현재 엘라스틱 서치의 상태를

    cat API를 사용하여 확인이 가능하다.
    해당 API를 사용하여 주로 노드, 샤드, 템플릿등의 상태나 통계정보를 확인하며

    현재 클러스터의 상태를 빠르게 확인이 가능하다.
    
  ```
#### 인덱스와 도큐먼트
  ```
    엘라스틱 서치를 이해하기 위해 인덱스와 도큐먼트는 매우 중요한 요소이다..

    인덱스는 도큐먼트를 저장하는 논리적 구분자이며, 도큐먼트는 실제 데이터를 저장하는 단위이다.
    아래 이미지는 클러스터, 인덱스, 도큐먼트들 간의 관계를 시각적으로 보여준다.
  ```
  - ![엘라1](https://github.com/pnci1029/TIL/assets/81909140/a99285e1-a3e5-4b73-a2c9-f5a00bf94243)
  ```
    1. 일반적으로 하나의 프로젝트에서 하나의 클러스터를 생성한다.

    2. 클러스터 내부에는 데이터 성격에 따른 여러개의 인덱스를 생성하고,

    3. 인덱스 내부에는 JSON 형태로 된 다수의 도큐먼트들이 존재하며,

    4. 도큐먼트는 복수의 필드들을 갖는다.
  ```
  `도큐먼트`
  ```
    도큐먼트는 데이터가 저장되는 기본 단위로 JSON형태이다.

    하나의 도큐먼트는 여러 필드와 값(value)를 갖는다.
  ```
  `인덱스`
  ```
    인덱스는 도큐먼트를 저장하는 논리적 단위이다.

    관계형 데이터베이스의 테이블과 유사한 개념으로, 하나의 인덱스에 다수의 도큐먼트를 갖는 구조를 갖는다.

    동일한 인덱스에 있는 도큐먼트는 동일한 스키마를 갖는다.
    인덱스 이름은 영어는 대문자로만 사용이 가능하며, 255바이트를 넘을 수 없다.
  ```
#### 도큐먼트 CRUD
  `인덱스 생성/확인/삭제`
    - <img width="1647" alt="스크린샷 2023-07-19 오후 11 04 18" src="https://github.com/pnci1029/TIL/assets/81909140/624d816f-bd40-4803-9ca7-37b626bf74e9">
  ```
    도큐먼트는 반드시 하나의 인덱스에 포함되어야한다. 따라서 도큐먼트를 생성하기전 인덱스 생성이 필요하다.

    인덱스 생성
    PUT test_index

    인덱스 조회
    GET test_index

    인덱스 삭제
    DELETE test_index
  ```
  `도큐먼트 생성`
    - <img width="1668" alt="스크린샷 2023-07-19 오후 11 06 21" src="https://github.com/pnci1029/TIL/assets/81909140/e909622e-df6c-49ab-9c66-236294c20f05">
  ```
    PUT test_index/_doc/1
    {
      "name" : "tester",
      "age" : 10,
      "gender" : "female"
    }

    생성된 인덱스에 name, age, gender 필드를 가지는 도큐먼트 생성
  ```
  `도큐먼트 조회`
    - <img width="1679" alt="스크린샷 2023-07-19 오후 11 07 57" src="https://github.com/pnci1029/TIL/assets/81909140/6e481623-3e30-456e-9782-f941785d9c8e">
  ```
    GET test_index/_doc/1
  ```
  `도큐먼트 수정`
  ```
    특정 필드값 수정 시
    PUT test_index/_doc/1
    {
      "name" : "tester1",
      "age" : 15,
      "gender" : "female"
    }

    혹은 _update API를 사용하여 특정 필드만 추가 업데이트도 가능하다.
    PUT test_index/_doc/1
    {
    "doc":{
        "name" : "tester111111",
      }
    }
  ```
  `도큐먼트 삭제`
  ```
    DELETE test_index/_doc/1
  ```
#### 벌크데이터
  ```
    엘라스틱 서치 API를 사용하여 CRUD 처리를 매번 하는것보다
    벌크로 한번에 처리하는것이 효율적이다.

    매번 발생하는 HTTP 통신과정을
    엘라스틱 서치 Bulk API를 사용하여 Rest API 콜 횟수를 줄여 성능을 높일 수 있다.

    벌크 API는 도큐먼트 읽기는 지원하지않고, 수정 삭제 생성만 지원한다.

  ```
#### 매핑
  ```
    관계형 데이터베이스에서 테이블 설계시 스키마(테이블을 구성하는 요소와 요소간 논리적 관계)가 반드시 필요하다.

    엘라스틱 서치에서 스키마와 비슷한 역할을 하는게 있는데, 이는 매핑이다.

    JSON형식의 데이터가 들어왔을 때 루씬이 이해할 수 있도록 바꿔주는 작업이다.

    엘라스틱 서치가 검색엔진으로써 대용량 데이터를 빠르게 실시간 검색할 수 있는 이유는 매핑이 있기 때문인데,

    엘라스틱 서치가 자동으로 매핑 처리를 하는것을 다이나믹 매핑,
    사용자가 매핑 처리하는것을 명시적 매핑이라고 한다.
  ```
  `다이나믹 매핑`
  ```
    엘라스틱 서치의 모든 인덱스는 매핑 정보를 가지고 있지만,
    유연할 활용을 위해 인덱스 생성 시 매핑 정의를 강제하지 않는다,

    앞서 PUT test_index 처리를 하며 인덱스 생성시 매핑 정보를 기입하지않았다.

    이는 엘라스틱 서치의 다이나믹 매핑 기능덕분이다.
  ```
- <img width="1715" alt="스크린샷 2023-07-20 오후 9 50 56" src="https://github.com/pnci1029/TIL/assets/81909140/0922476d-0adf-4454-9b40-91e9192ea23c">

  ```
    엘라스틱 서치에서 다이나믹 매핑 시

    mapping API를 사용하여 인덱스의 매핑 정보를 조회 할 수 있다.
    GET test_index/_mapping

    age 값은 Integer로 입력이 되어 다이나믹 매핑 시 Integer의 가장 긴 타입인 long 타입으로 저장된다.
    age 필드는 나이를 받는 값이기 때문에 메모리 사용 측면에서 short으로 매핑정보를 직접 바꿔서 사용하는게 추후 유리할 것이다.

    텍스트/키워드 타입은 추후에.......
  ```
  `명시적 매핑`
  - <img width="1692" alt="스크린샷 2023-07-20 오후 9 59 26" src="https://github.com/pnci1029/TIL/assets/81909140/58e5af3d-5d50-436f-aa11-9d875fd7e06b">

  ```
    인덱스 매핑을 사용자가 직접 기입하는것을 명시적 매핑이라고 한다.
      PUT test_index3
      {
        "mappings": {
          "properties": {
            "age2": {"type": "short"},
            "name2" : {"type": "text"},
            "gender" : {"type": "keyword"}
          }
        }
      }

    저장할 데이터 타입이나, 데이터를 알고있다면 직접 매핑해주는게 좋다.
    인덱스 매핑이 지정되면 새로운 필드를 추가 정의는 가능하나, 이미 정의된 필드를 수정이나 삭제할 수는 없다.

    따라서 인덱스 매핑 시 신중하게 하는것이 중요하다.
  ```
`매핑 타입`
  ```
    명시적 매핑을 위해서는 매핑 타입을 정확하게 이해하고 있는게 중요하다.

    다양한 매핑 타입이 존재하지만 자주 사용되는 매핑 용어를 익히고, 잘 활용하여 인덱스 성능을 올리는것이 중요하다.
  ```
#  
#  
|데이터 형태|데이터 타입|설명|
|------|---|---|
|텍스트 타입|text|전문 검색이 필요한 데이터로 텍스트 분석기가 텍스트를 작은 단위로 분리한다.|
|텍스트 타입|keyword|정렬이나 집계에 사용되는 텍스트 데이터로 분석을 하지 않고 원문 통째로 인덱싱한다.|
|날짜|date|날짜/시간데이터|
|정수|byte, short, integer, long|각각 8, 16, 32, 64비트|
|실수|scaled_float, half_float, double, float|scaled를 제외하고 각각 16, 32, 64 부동소수점 실수 데이터|
|boolean|boolean|true / false 값만 가짐|
|IP주소|ip|ipv4, ipv6타입 ip주소를 입력할 수 있다.|
|위치정보|geo-point, geo-shape|각각 위도경도, 임의의 지형 값을 갖는다. |
|범위값|integer_range, long_range, float_range, double_range, ip_range, date_range|범위를 설정할 수 있는 데이터|
|객체형|object|계층 구조를 갖는 형태로, 필드안에 다른 필드들이 들어갈 수 있다. ex) name:{"fisrt:"kim","last":"tony"}|
|배열형|nested|배열형 객체를 저장한다. 배열 내부의 객체에 쿼리로 접근 가능하다.|
|배열형|join|부모 - 자식 관계를 표현할 수 있다.|
#  
#  
  `문자열 처리`
  ```
    엘라스틱 서치에서 텍스트 타입은 일반적으로 문장을 저장하는 매핑 타입으로 사용된다.

    일반적으로 문장이나, 여러 단어가 나열된 문자열을 텍스트 타입으로 지정한다.

    ex)
    "We offer solutions for enterprise search, observability, and security that are build on a single, flexible technology stack that can be deployed anywhere."

    텍스트 타입으로 지정된 문자열은 분석기(analyzer)에 의해 토큰으로 분리되고, 이렇게 분리된 토큰들은 인덱싱되는데, 이를 역인덱싱이라고 한다.

    이때 역인덱스에 저장된 토큰들을 용어(term)라고 한다. 
  ```
  - <img width="1685" alt="스크린샷 2023-07-20 오후 10 18 22" src="https://github.com/pnci1029/TIL/assets/81909140/86f0426e-94ba-4b84-b3ff-b463d8ae5452">
  ```
    텍스트들이 [we, offer, solutions, ...]와 같은 토큰으로 분리되고, 대소문자를 통일하는 등 가공 과정을 거쳐 용어(term)가 된다.
    
  ```
#  
  `텍스트 타입`
  - <img width="1727" alt="스크린샷 2023-07-20 오후 10 24 02" src="https://github.com/pnci1029/TIL/assets/81909140/2dd57b41-69ce-480f-ade8-e4e680885e14">
  ```
    1. 인덱스 생성
    2. 생성된 인덱스에 도큐먼트 인덱싱
    3. 생성된 도큐먼트 조회

    역인덱싱된 용어 중 하나라도 포함되면 해당 도큐먼트를 찾는다.

    관계형 db의 like절과 유사하지만, like 검색은 인덱싱이 되지않아 엘라스틱 서치처럼 대용량 검색을 하는데 문제가 있다.

    * 텍스트 타입은 기본적으로 집계나 정렬을 지원하지 않으며, 매핑 파라미터로 집계나 정렬을 지원 가능하나, 메모리를 많이 사용한다는 단점이 있다.
    텍스트 타입으로 지정된 필드를 정렬할 경우 문장의 첫 문자열이 아닌 분해된 용어를 기준으로 정렬을 수행해야 하므로 결과가 예측치와 달라질 수 있다.

    전문 검색이 아닌 집계나 정렬은 키워드 타입을 사용해야한다.
  ```
  `키워드 타입`
  ```
    키워드 타입은 카테고리나 사람이름, 브랜드등 규칙성이나 유의미한 값들의 집합에 주로 사용된다.

    키워드 타입은 텍스트 타입과 다르게 분석기를 거치지 않고 문자열 전체가 하나의 용어로 인덱싱된다.

    ex)
    "We offer solutions for enterprise search, observability, and security that are build on a single, flexible technology stack that can be deployed anywhere."
    예시의 문장은 we, offer, ...등 역인덱싱된 용어 전체 갯수만큼 분리됐는데,

    키워드 타입은 위 문자열을 1개의 용어로 만든다.

    따라서 키워드 타입으로 매핑된 데이터는 부분일치검색은 어렵지만 완전 일치 검색을 위해 사용할 수 있으며, 정렬이나 집계에 주료 사용된다.

    예를들어 성별을 나타내는 필드(male, female)는 용어를 분리할 필요가 없다.

    이러한 범주형 데이터는 형태가 고정되기 때문에 문자열 집계나 정렬 작업에 활용도가 더 높다.
  ```
  - <img width="1718" alt="스크린샷 2023-07-20 오후 10 37 25" src="https://github.com/pnci1029/TIL/assets/81909140/ab8dfc33-e6de-4dc1-b169-d5dccf20fedf">

  ```
    앞서 텍스트 타입과 달리 문장 전체가 하나의 용어가 되어 도큐먼트를 찾을 수 없다.

    키워드 타입에서 결과를 올바르게 찾으려면 "beautiful day"를 똑같이 검색하는 방법밖에없다.
  ```
  `멀티 필드`
  ```
    멀티필드는 단일 필드 입력에 대해 여러 하위 필드를 정의하는 기능으로,
    이를 위해 fileds라는 매핑 파라미터가 사용된다.

    문자열의 경우 전문 검색이 필요하면서 정렬도 필요한 경우가 있다.


    이런 경우 처음 매핑할 때 텍스트와 키워드를 동시에 지원해야한다.

  ```

  - <img width="1718" alt="스크린샷 2023-07-20 오후 10 46 05" src="https://github.com/pnci1029/TIL/assets/81909140/9c7e206c-e1d5-42f3-b5cc-2334dd42b75a">

  ```
    3개의 도큐먼트가 모두 검색된다.

    contents는 멀티필드이지만 기본적으로 텍스트타입으로 매핑되어있다.
    따라서 용어가 분리되어 모두 검색결과로 얻을 수 있었다.

    키워드 조회 시 조금 다른 접근이 필요하다.
  ```
  #  

  - <img width="1704" alt="스크린샷 2023-07-20 오후 10 49 39" src="https://github.com/pnci1029/TIL/assets/81909140/d0f9f89a-ecdb-4d9b-8306-1025ff5a725a">
  
  ```
    contents 뒤에 keyword를 추가하여 하위 필드를 참조 할 수 있다.
  ```
#  

  - <img width="1711" alt="스크린샷 2023-07-20 오후 10 52 47" src="https://github.com/pnci1029/TIL/assets/81909140/61f96a67-4bda-4ee6-9153-c9ae2f15f497">
  ```
    키워드 타입은 또한 집계에서 활용도가 큰데, 위와같은 쿼리를 통해
    contents.keyword 값이 같은 도큐먼트끼리 그룹핑이된다.
  ```
####인덱스 템플릿
  ```
    인덱스 템플릿은 주로 설정이 동일한 인덱스를 만들 때 사용된다.

    설정이 동일한 인덱스를 여러차례 생성하는것은 비효율적일 뿐 아니라 실수를 유발한다.

  ```
  `인덱스 템플릿 생성`
  - <img width="1713" alt="스크린샷 2023-07-22 오후 1 51 18" src="https://github.com/pnci1029/TIL/assets/81909140/c7939b2e-4050-4423-aa9f-4e48454ce4fd">

|파라미터|설명|
|------|---|
|index_patterns|새로 만들어지는 인덱스 중 인덱스 이름이 인덱스 패턴과 매칭되는 경우 해당 인덱스 패턴 템플릿이 적용된다. 위 이미지 같은 경우 my_index_template의 매핑, 세팅값이 적용됨|
|priority|인덱스 생성 시 이름에 매칭되는 템플릿이 둘 이상일 때 템플릿에 적용되는 우선순위를 정할 수 있다. 숫자가 높을 수록 먼저 적용된다.|
|template|새로 생성되는 인덱스에 적용되는 settings, mappings 같은 인덱스 설정을 정의한다.|
    
  `템플릿 적용`
  ```
    템플릿을 만들기 전 이미 존재하는 인덱스는 템플릿 패턴과 일치하더라도 템플릿이 적용되지않는다.

    오직 템플릿 생성 후에 만들어지는 인덱스들만이 템플릿의 영향을 받는다.
  ```
  - 템플릿이 적용된 인덱스
  - <img width="1722" alt="스크린샷 2023-07-22 오후 2 02 49" src="https://github.com/pnci1029/TIL/assets/81909140/5e8bc8ec-e5b2-498b-aec6-2d87abe86cd3">
  #  
  #  
  #  
  - 템플릿이 적용안된 인덱스
  - <img width="1715" alt="스크린샷 2023-07-22 오후 2 04 09" src="https://github.com/pnci1029/TIL/assets/81909140/3856c323-ecd9-4420-9ac9-15b36aac566f">
  #  
  #  
  #  
  - 템플릿과 다른 타입의 필드를 기입했을때
  - <img width="1720" alt="스크린샷 2023-07-22 오후 2 07 14" src="https://github.com/pnci1029/TIL/assets/81909140/6802b35a-fb39-4607-913c-8a11c9971c7b">
  #  
  #  






