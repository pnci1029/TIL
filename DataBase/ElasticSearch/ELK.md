<img width="1719" alt="스크린샷 2023-08-02 오후 10 27 59" src="https://github.com/pnci1029/TIL/assets/81909140/622751a6-ced7-4cad-8ee6-6630ebe79004"># Chapter 1
#  
## 엘라스틱서치: 분산 검색엔진
  ```
    엘라스틱 서치는 검색엔진이지만 일반적인 네이버, 구글같은 검색포털과는 다르다.

    검색엔진은 내부적으로 각 도큐먼트를 엔덱싱하고 빠르게 검색하는데 사용하는 기술로, 네이버나 구글같은 검색 포털은 해당 검색엔진을 사용하여 만들게된다.

    엘라스틱 서치는 모든 레코드를 JSON 형태로 관리하고, 요청된 쿼리에 일치하는 결과값만 반환한다.
    엘라스틱 서치는 텍스트나 도큐먼트의 경우, 인덱싱 시점에 분석을 거쳐 용어 단위로 분해되고 역인덱스 사전을 구축한다.

    이렇게 최적화된 자료구조들을 바탕으로 병렬처리나 분산처리를 할 수 있다.

  ```
#  
  `검색엔진`
  ```
    엘라스틱 서치가 다른 관계형 DB나 다른 NoSQL DB에 비해 빠른 검색과 집계 성능을 실형하는 이유는, 검색엔진이면서 DB이기 때문이다.

    엘라스틱서치는 몽고디비와 같은 도큐먼트 형태의 NoSQL이지만, 검색과 성능이라는 측면에서 가장 크게 구별된다.

    특히 검색엔진으로써 가장 큰 특징중 하나는 스코어링, 즉 연관도에 따른 정렬이다.

    단순히 필드값을 기준으로 한 정렬은 어떤 종류의 데이터베이스에서도 제공되지만,
    엘라스틱 서치는 다양한 스코어링 방법을 포함하여 사용자가 정렬방식을 직접 정의할 수 있다.
  ```
#  
  - ![es_01](https://github.com/pnci1029/TIL/assets/81909140/25461efe-c96b-447b-9010-97f1759df8c7)
  `분산 시스템`
  ```
    엘라스틱 서치는 분산시스템으로서 복수의 인스턴스를 병렬로 배치하고 분산처리를 하여,
    검색속도를 무한히 확장 할 수 있게 했다.

    또한 노드간 복제 기능을 통해 일부 노드가 다운되더라도 정상적으로 서비스를 지숙가능하게 해준다.
    무엇보다 RestApi를 통해 프로그래밍 언어와 무관하게 사용자가 직접 접근할 수 있도록 활용성이 높다.

  ```
#  
  `단점` 
  ```
    그러나 저장공간이 크게 압축되지 않고 시스템 리소스를 많이사용하는 단점도 있다.

    그리고 DSL 쿼리를 사용하는데, JOIN코리가 어렵기 떄문에 사실상 반정규화를 기본으로 모델링해야한다.

    또한 인덱스가 불변의 자료구조이기때문에 도큐먼트를 수정하거나 사용할 경우 비용이 저렴하지않다.

    이러한 단점들은 검색 성능을 끌어올리기위해 트레이드오프가 이뤄진것으로,
    대량의 데이터를 처리할 때는 일반적으로 용인되는 제약이다.

    결과적으로 대용량 데이터에 대한 빠른 검색과 집계가 필요할 경우 고려해야하는 데이터베이스라고 할 수 있다.
  ```
#  
  -![키바나](https://github.com/pnci1029/TIL/assets/81909140/ea92a404-6818-4dcf-9254-7b90714f4774)
  `키바나`
  ```
    엘라스틱 서치가 RestApi가 잘 설계되었지만 복잡한 요청을 일일이 작성하기엔 불편함이 있다.

    키바나는 이런 불편함을 해소시켜주고 일종의 엘라스틱서치의 UI역할을 담당한다.

    엘라스틱 서치의 대부분의 관리기능, API콘솔, 모니터링 페이지등이 키바나에 포함된다.


    무엇보다 큰 특징은 시각화 대시보드이다.
    일반적으로 여러 차트나 그래프등의 시각도구들을 쉽게 구성하게해주고,
    이런 기능들이 엘라스틱서치의 대중화와 확산에 큰 공헌을 했다.
  ```
#  
  `로그스태시`
  ```
    로그스태시는 이벤트 수집과 정제를 위한 도구이다.

    대량의 데이터를 검색하기 위해 가장 먼저 선행돼아 할 작업은 데이터를 적재하는것이다.

    이는 빅데이터를 다룰 때 가장 손이 많은 작업이며, 엘라스틱 서치의 데이터 수집과 가공 기능은 로그스태시를 사용한다.
  ```
# Chapter 2
#  
  ```
  
  ```
# Chapter 3
## 엘라스틱 서치 기본
  ```
    처음 새로운 시스템을 접하게되면 두가지 난간에 부딪힌다.
    시스템을 알기위해서는 용어와 개념이 필요하다.

    새로 접한 시스템에서 용어와 개념은 머리에 들어오지않고, 결과적으로 시스템을 이해하기 어렵다.

    직접 검색엔진을 구축해본 경험이 없는 이상

    엘라스틱 서치 역시 마찬가지다.
  ```
  ```
    엘라스틱 서치를 제대로 활용하기 위해서는

    저장과 인출방식을 확실해 이해해야한다.

    1. 인출을 위해서는 가장먼저 저장이 필요하다.

    2. 저장을 하기위해서는 스키마를 구성하고 데이터를 집어넣어야한다.

    3. 이 과정에서 데이터 타입을 배우고 검색 내부 동작을 이해한다.
  ```
### 엘라스틱 서치 API 활용
#### 시스템 상태 확인
  - <img width="1661" alt="스크린샷 2023-07-19 오후 10 42 10" src="https://github.com/pnci1029/TIL/assets/81909140/0e9434d4-19fb-4012-8c37-f7fa7b9640b8">
  ```
    키바나 콘솔을 통해 현재 엘라스틱 서치의 상태를

    cat API를 사용하여 확인이 가능하다.
    해당 API를 사용하여 주로 노드, 샤드, 템플릿등의 상태나 통계정보를 확인하며

    현재 클러스터의 상태를 빠르게 확인이 가능하다.
    
  ```
#### 인덱스와 도큐먼트
  ```
    엘라스틱 서치를 이해하기 위해 인덱스와 도큐먼트는 매우 중요한 요소이다..

    인덱스는 도큐먼트를 저장하는 논리적 구분자이며, 도큐먼트는 실제 데이터를 저장하는 단위이다.
    아래 이미지는 클러스터, 인덱스, 도큐먼트들 간의 관계를 시각적으로 보여준다.
  ```
  - ![엘라1](https://github.com/pnci1029/TIL/assets/81909140/a99285e1-a3e5-4b73-a2c9-f5a00bf94243)
  ```
    1. 일반적으로 하나의 프로젝트에서 하나의 클러스터를 생성한다.

    2. 클러스터 내부에는 데이터 성격에 따른 여러개의 인덱스를 생성하고,

    3. 인덱스 내부에는 JSON 형태로 된 다수의 도큐먼트들이 존재하며,

    4. 도큐먼트는 복수의 필드들을 갖는다.
  ```
  `도큐먼트`
  ```
    도큐먼트는 데이터가 저장되는 기본 단위로 JSON형태이다.

    하나의 도큐먼트는 여러 필드와 값(value)를 갖는다.
  ```
  `인덱스`
  ```
    인덱스는 도큐먼트를 저장하는 논리적 단위이다.

    관계형 데이터베이스의 테이블과 유사한 개념으로, 하나의 인덱스에 다수의 도큐먼트를 갖는 구조를 갖는다.

    동일한 인덱스에 있는 도큐먼트는 동일한 스키마를 갖는다.
    인덱스 이름은 영어는 대문자로만 사용이 가능하며, 255바이트를 넘을 수 없다.
  ```
#### 도큐먼트 CRUD
  `인덱스 생성/확인/삭제`
  
  - <img width="1647" alt="스크린샷 2023-07-19 오후 11 04 18" src="https://github.com/pnci1029/TIL/assets/81909140/624d816f-bd40-4803-9ca7-37b626bf74e9">
  ```
    도큐먼트는 반드시 하나의 인덱스에 포함되어야한다. 따라서 도큐먼트를 생성하기전 인덱스 생성이 필요하다.

    인덱스 생성
    PUT test_index

    인덱스 조회
    GET test_index

    인덱스 삭제
    DELETE test_index
  ```
  `도큐먼트 생성`
  
  - <img width="1668" alt="스크린샷 2023-07-19 오후 11 06 21" src="https://github.com/pnci1029/TIL/assets/81909140/e909622e-df6c-49ab-9c66-236294c20f05">
  ```
    PUT test_index/_doc/1
    {
      "name" : "tester",
      "age" : 10,
      "gender" : "female"
    }

    생성된 인덱스에 name, age, gender 필드를 가지는 도큐먼트 생성
  ```
  `도큐먼트 조회`
  
  - <img width="1679" alt="스크린샷 2023-07-19 오후 11 07 57" src="https://github.com/pnci1029/TIL/assets/81909140/6e481623-3e30-456e-9782-f941785d9c8e">
  ```
    GET test_index/_doc/1
  ```
  `도큐먼트 수정`
  ```
    특정 필드값 수정 시
    PUT test_index/_doc/1
    {
      "name" : "tester1",
      "age" : 15,
      "gender" : "female"
    }

    혹은 _update API를 사용하여 특정 필드만 추가 업데이트도 가능하다.
    PUT test_index/_doc/1
    {
    "doc":{
        "name" : "tester111111",
      }
    }
  ```
  `도큐먼트 삭제`
  ```
    DELETE test_index/_doc/1
  ```
#### 벌크데이터
  ```
    엘라스틱 서치 API를 사용하여 CRUD 처리를 매번 하는것보다
    벌크로 한번에 처리하는것이 효율적이다.

    매번 발생하는 HTTP 통신과정을
    엘라스틱 서치 Bulk API를 사용하여 Rest API 콜 횟수를 줄여 성능을 높일 수 있다.

    벌크 API는 도큐먼트 읽기는 지원하지않고, 수정 삭제 생성만 지원한다.

  ```
#### 매핑
  ```
    관계형 데이터베이스에서 테이블 설계시 스키마(테이블을 구성하는 요소와 요소간 논리적 관계)가 반드시 필요하다.

    엘라스틱 서치에서 스키마와 비슷한 역할을 하는게 있는데, 이는 매핑이다.

    JSON형식의 데이터가 들어왔을 때 루씬이 이해할 수 있도록 바꿔주는 작업이다.

    엘라스틱 서치가 검색엔진으로써 대용량 데이터를 빠르게 실시간 검색할 수 있는 이유는 매핑이 있기 때문인데,

    엘라스틱 서치가 자동으로 매핑 처리를 하는것을 다이나믹 매핑,
    사용자가 매핑 처리하는것을 명시적 매핑이라고 한다.
  ```
  `다이나믹 매핑`
  ```
    엘라스틱 서치의 모든 인덱스는 매핑 정보를 가지고 있지만,
    유연할 활용을 위해 인덱스 생성 시 매핑 정의를 강제하지 않는다,

    앞서 PUT test_index 처리를 하며 인덱스 생성시 매핑 정보를 기입하지않았다.

    이는 엘라스틱 서치의 다이나믹 매핑 기능덕분이다.
  ```
- <img width="1715" alt="스크린샷 2023-07-20 오후 9 50 56" src="https://github.com/pnci1029/TIL/assets/81909140/0922476d-0adf-4454-9b40-91e9192ea23c">

  ```
    엘라스틱 서치에서 다이나믹 매핑 시

    mapping API를 사용하여 인덱스의 매핑 정보를 조회 할 수 있다.
    GET test_index/_mapping

    age 값은 Integer로 입력이 되어 다이나믹 매핑 시 Integer의 가장 긴 타입인 long 타입으로 저장된다.
    age 필드는 나이를 받는 값이기 때문에 메모리 사용 측면에서 short으로 매핑정보를 직접 바꿔서 사용하는게 추후 유리할 것이다.

    텍스트/키워드 타입은 추후에.......
  ```
  `명시적 매핑`
  - <img width="1692" alt="스크린샷 2023-07-20 오후 9 59 26" src="https://github.com/pnci1029/TIL/assets/81909140/58e5af3d-5d50-436f-aa11-9d875fd7e06b">

  ```
    인덱스 매핑을 사용자가 직접 기입하는것을 명시적 매핑이라고 한다.
      PUT test_index3
      {
        "mappings": {
          "properties": {
            "age2": {"type": "short"},
            "name2" : {"type": "text"},
            "gender" : {"type": "keyword"}
          }
        }
      }

    저장할 데이터 타입이나, 데이터를 알고있다면 직접 매핑해주는게 좋다.
    인덱스 매핑이 지정되면 새로운 필드를 추가 정의는 가능하나, 이미 정의된 필드를 수정이나 삭제할 수는 없다.

    따라서 인덱스 매핑 시 신중하게 하는것이 중요하다.
  ```
`매핑 타입`
  ```
    명시적 매핑을 위해서는 매핑 타입을 정확하게 이해하고 있는게 중요하다.

    다양한 매핑 타입이 존재하지만 자주 사용되는 매핑 용어를 익히고, 잘 활용하여 인덱스 성능을 올리는것이 중요하다.
  ```
#  
#  
|데이터 형태|데이터 타입|설명|
|------|---|---|
|텍스트 타입|text|전문 검색이 필요한 데이터로 텍스트 분석기가 텍스트를 작은 단위로 분리한다.|
|텍스트 타입|keyword|정렬이나 집계에 사용되는 텍스트 데이터로 분석을 하지 않고 원문 통째로 인덱싱한다.|
|날짜|date|날짜/시간데이터|
|정수|byte, short, integer, long|각각 8, 16, 32, 64비트|
|실수|scaled_float, half_float, double, float|scaled를 제외하고 각각 16, 32, 64 부동소수점 실수 데이터|
|boolean|boolean|true / false 값만 가짐|
|IP주소|ip|ipv4, ipv6타입 ip주소를 입력할 수 있다.|
|위치정보|geo-point, geo-shape|각각 위도경도, 임의의 지형 값을 갖는다. |
|범위값|integer_range, long_range, float_range, double_range, ip_range, date_range|범위를 설정할 수 있는 데이터|
|객체형|object|계층 구조를 갖는 형태로, 필드안에 다른 필드들이 들어갈 수 있다. ex) name:{"fisrt:"kim","last":"tony"}|
|배열형|nested|배열형 객체를 저장한다. 배열 내부의 객체에 쿼리로 접근 가능하다.|
|배열형|join|부모 - 자식 관계를 표현할 수 있다.|
#  
#  
  `문자열 처리`
  ```
    엘라스틱 서치에서 텍스트 타입은 일반적으로 문장을 저장하는 매핑 타입으로 사용된다.

    일반적으로 문장이나, 여러 단어가 나열된 문자열을 텍스트 타입으로 지정한다.

    ex)
    "We offer solutions for enterprise search, observability, and security that are build on a single, flexible technology stack that can be deployed anywhere."

    텍스트 타입으로 지정된 문자열은 분석기(analyzer)에 의해 토큰으로 분리되고, 이렇게 분리된 토큰들은 인덱싱되는데, 이를 역인덱싱이라고 한다.

    이때 역인덱스에 저장된 토큰들을 용어(term)라고 한다. 
  ```
  - <img width="1685" alt="스크린샷 2023-07-20 오후 10 18 22" src="https://github.com/pnci1029/TIL/assets/81909140/86f0426e-94ba-4b84-b3ff-b463d8ae5452">
  ```
    텍스트들이 [we, offer, solutions, ...]와 같은 토큰으로 분리되고, 대소문자를 통일하는 등 가공 과정을 거쳐 용어(term)가 된다.
    
  ```
#  
  `텍스트 타입`
  - <img width="1727" alt="스크린샷 2023-07-20 오후 10 24 02" src="https://github.com/pnci1029/TIL/assets/81909140/2dd57b41-69ce-480f-ade8-e4e680885e14">
  ```
    1. 인덱스 생성
    2. 생성된 인덱스에 도큐먼트 인덱싱
    3. 생성된 도큐먼트 조회

    역인덱싱된 용어 중 하나라도 포함되면 해당 도큐먼트를 찾는다.

    관계형 db의 like절과 유사하지만, like 검색은 인덱싱이 되지않아 엘라스틱 서치처럼 대용량 검색을 하는데 문제가 있다.

    * 텍스트 타입은 기본적으로 집계나 정렬을 지원하지 않으며, 매핑 파라미터로 집계나 정렬을 지원 가능하나, 메모리를 많이 사용한다는 단점이 있다.
    텍스트 타입으로 지정된 필드를 정렬할 경우 문장의 첫 문자열이 아닌 분해된 용어를 기준으로 정렬을 수행해야 하므로 결과가 예측치와 달라질 수 있다.

    전문 검색이 아닌 집계나 정렬은 키워드 타입을 사용해야한다.
  ```
  `키워드 타입`
  ```
    키워드 타입은 카테고리나 사람이름, 브랜드등 규칙성이나 유의미한 값들의 집합에 주로 사용된다.

    키워드 타입은 텍스트 타입과 다르게 분석기를 거치지 않고 문자열 전체가 하나의 용어로 인덱싱된다.

    ex)
    "We offer solutions for enterprise search, observability, and security that are build on a single, flexible technology stack that can be deployed anywhere."
    예시의 문장은 we, offer, ...등 역인덱싱된 용어 전체 갯수만큼 분리됐는데,

    키워드 타입은 위 문자열을 1개의 용어로 만든다.

    따라서 키워드 타입으로 매핑된 데이터는 부분일치검색은 어렵지만 완전 일치 검색을 위해 사용할 수 있으며, 정렬이나 집계에 주료 사용된다.

    예를들어 성별을 나타내는 필드(male, female)는 용어를 분리할 필요가 없다.

    이러한 범주형 데이터는 형태가 고정되기 때문에 문자열 집계나 정렬 작업에 활용도가 더 높다.
  ```
  - <img width="1718" alt="스크린샷 2023-07-20 오후 10 37 25" src="https://github.com/pnci1029/TIL/assets/81909140/ab8dfc33-e6de-4dc1-b169-d5dccf20fedf">

  ```
    앞서 텍스트 타입과 달리 문장 전체가 하나의 용어가 되어 도큐먼트를 찾을 수 없다.

    키워드 타입에서 결과를 올바르게 찾으려면 "beautiful day"를 똑같이 검색하는 방법밖에없다.
  ```
  `멀티 필드`
  ```
    멀티필드는 단일 필드 입력에 대해 여러 하위 필드를 정의하는 기능으로,
    이를 위해 fileds라는 매핑 파라미터가 사용된다.

    문자열의 경우 전문 검색이 필요하면서 정렬도 필요한 경우가 있다.


    이런 경우 처음 매핑할 때 텍스트와 키워드를 동시에 지원해야한다.

  ```

  - <img width="1718" alt="스크린샷 2023-07-20 오후 10 46 05" src="https://github.com/pnci1029/TIL/assets/81909140/9c7e206c-e1d5-42f3-b5cc-2334dd42b75a">

  ```
    3개의 도큐먼트가 모두 검색된다.

    contents는 멀티필드이지만 기본적으로 텍스트타입으로 매핑되어있다.
    따라서 용어가 분리되어 모두 검색결과로 얻을 수 있었다.

    키워드 조회 시 조금 다른 접근이 필요하다.
  ```
  #  

  - <img width="1704" alt="스크린샷 2023-07-20 오후 10 49 39" src="https://github.com/pnci1029/TIL/assets/81909140/d0f9f89a-ecdb-4d9b-8306-1025ff5a725a">
  
  ```
    contents 뒤에 keyword를 추가하여 하위 필드를 참조 할 수 있다.
  ```
#  

  - <img width="1711" alt="스크린샷 2023-07-20 오후 10 52 47" src="https://github.com/pnci1029/TIL/assets/81909140/61f96a67-4bda-4ee6-9153-c9ae2f15f497">
  ```
    키워드 타입은 또한 집계에서 활용도가 큰데, 위와같은 쿼리를 통해
    contents.keyword 값이 같은 도큐먼트끼리 그룹핑이된다.
  ```
#### 인덱스 템플릿
  ```
    인덱스 템플릿은 주로 설정이 동일한 인덱스를 만들 때 사용된다.

    설정이 동일한 인덱스를 여러차례 생성하는것은 비효율적일 뿐 아니라 실수를 유발한다.

  ```
  `인덱스 템플릿 생성`
  
  - <img width="1713" alt="스크린샷 2023-07-22 오후 1 51 18" src="https://github.com/pnci1029/TIL/assets/81909140/c7939b2e-4050-4423-aa9f-4e48454ce4fd">

|파라미터|설명|
|------|---|
|index_patterns|새로 만들어지는 인덱스 중 인덱스 이름이 인덱스 패턴과 매칭되는 경우 해당 인덱스 패턴 템플릿이 적용된다. 위 이미지 같은 경우 my_index_template의 매핑, 세팅값이 적용됨|
|priority|인덱스 생성 시 이름에 매칭되는 템플릿이 둘 이상일 때 템플릿에 적용되는 우선순위를 정할 수 있다. 숫자가 높을 수록 먼저 적용된다.|
|template|새로 생성되는 인덱스에 적용되는 settings, mappings 같은 인덱스 설정을 정의한다.|
    
  `템플릿 적용`
  
  ```
    템플릿을 만들기 전 이미 존재하는 인덱스는 템플릿 패턴과 일치하더라도 템플릿이 적용되지않는다.

    오직 템플릿 생성 후에 만들어지는 인덱스들만이 템플릿의 영향을 받는다.
  ```
  - 템플릿이 적용된 인덱스
  - <img width="1722" alt="스크린샷 2023-07-22 오후 2 02 49" src="https://github.com/pnci1029/TIL/assets/81909140/5e8bc8ec-e5b2-498b-aec6-2d87abe86cd3">
  #  
  #  
  #  
  - 템플릿이 적용안된 인덱스
  - <img width="1715" alt="스크린샷 2023-07-22 오후 2 04 09" src="https://github.com/pnci1029/TIL/assets/81909140/3856c323-ecd9-4420-9ac9-15b36aac566f">
  #  
  #  
  #  
  - 템플릿과 다른 타입의 필드를 기입했을때
  - <img width="1720" alt="스크린샷 2023-07-22 오후 2 07 14" src="https://github.com/pnci1029/TIL/assets/81909140/6802b35a-fb39-4607-913c-8a11c9971c7b">
  #  
  #  

  `템플릿 우선순위`
  
  - <img width="1717" alt="스크린샷 2023-07-22 오후 2 16 44" src="https://github.com/pnci1029/TIL/assets/81909140/498ccc0d-9771-433e-9564-f87fcc5f1bef">
  #  
  `다이나믹 템플릿`
  
  - <img width="1698" alt="스크린샷 2023-07-22 오후 2 36 58" src="https://github.com/pnci1029/TIL/assets/81909140/f957a66d-198d-4d84-aa02-2230ae133d0a">

  ```
    다이나믹 템플릿은 매핑을 정확하게 정할 수 없거나 대략적인 구조만 알고 있을 때 사용할 수 있는 방법이다.

    사용은 dynamic_templates를 추가하여 사용한다.
  ```
#  
#### 분석기
  ```
    분석기는 엘라스틱 서치에서 전문 검색을 지원하기 위한 역인덱싱 기술이며
    장문의 문자열에서 부분 검색을 위해 문자열을 분석해 작은 단위로 쪼개어 인덱싱 하는 기술을 의미한다.

    이를 위해 토크나이저, 토큰필터로 구성되어있는 분석기 모듈을 가지고 있다.

    분석기에는 반드시 하나의 토크나이저가 포함되야하고, 여러개를 함께 사용해도된다.

    사용자는 엘라스틱서치에서 제공하는 분석기를 사용하거나 필터와 토크나이저를 조합하여 원하는 분석기를 직접 만들어 사용하기도 한다.

  ```
  `토큰과 용어(term)`
  
  - ![토큰과용어](https://github.com/pnci1029/TIL/assets/81909140/a4d9e645-7cae-4c10-a233-cda205498048)
  
    ```
      여러 용어가 포함된 문장이 분석기를 거쳐 인덱스에 저장된다고 가정했을때,

      1. 분석기는 캐릭터 필터를 통해 불필요한 문자를 제거한다.
        * 문자열이 분리되지않고 필터링된 문자열로 이해

      2. 토크나이저를 통해 문자열을 다르게 되는데, 이때 잘린 단위를 토큰이라고 한다.

      3. 생성된 토큰들을 복수의 토큰 필터를 거쳐 정제가 된다.

      4. 정지 후 최종 역인덱스에 저장된 상태의 토큰들을 용어(term)라고 한다.

      토큰은 분석기 내부에서 일시적으로 존재하는 상태이고,
      인덱싱되어있는 단위나 검색에 사용되는 단위는 모두 용어라고 할 수 있다.
    
  `분석기 구성`
  |구성요소|설명|
  |------|---|
  |캐릭터 필터|입력받은 문자열을 변경하거나 불필요한 문자들을 제거한다. 정제작업|
  |토크나이저|분석기에 필수적으로 필요한 요소이며 문자열을 토큰으로 분리한다.|
  |토큰 필터|토큰들을 대소문자 구분, 형태소 분석등의 작업등으로 필터링 한다.|
#  
  `역인덱싱`
  
  - ![역인덱싱](https://github.com/pnci1029/TIL/assets/81909140/0faa8b81-8962-4aba-8a3b-0810b03ef63b)

  ```
    문자열을 토큰화하여 이를 인덱싱하는것을 말한다.
  ```
#  
  `분석기 종류`
  
  - ex) "The 10 most loving dob breeds."
  
  |분석기|설명|
  |------|---|
  |standard|특정 분석기 설정이 없을때 디폴트 값 분석기. 소문자 변경 필터 포함 -> [the, 10, most, loving, dog, breeds]|
  |simple|문자만 토큰화 -> [the, most, loving, dog, breeds]|
  |whitespace|공백을 기준으로 토큰화 -> [The, 10, most, loving, dog, breeds]|
#  
  `토크나이저`
  ```
    분석기에는 반드시 하나의 토크나이저를 포함해야한다.

    토크나이저는 문자열을 분리하여 토큰화 하는 중요한 역할을 한다.
  ```

  - 한글 형태소 분석기
  ```
    한글은 영어나 다른 언어와 비교했을때 품사나 합성어도 많고 자음과 모음의 구분으로 형태를 일반적인 방법으로 분석하기 어렵다.

    standard 분석기로 한글을 토큰화 했을 때 띄어쓰기에 따라 분리되는것을 볼 수 있다.

    Nori 한글 형태소 분식기는 엘라스틱서치에 기본적으로 포함되어 있는 한국어 형태소 분석기이며 mecab-ko-dic을 재가공하여 사용한다.

    korean-analyzer나, mecab-ko-dic 한글 형태소 사전 기반 토큰들을 가지고 한글 형태소를 분석
      `mecab-ko-dic은 21세기 세종계획 모든 현대 말뭉치에서 50문장씩을 추출하여 학습에 이용하였습니다. (총 23,615 문장)`

    
  ```
  `필터`
  ```
    필터는 분석기에서 필수요소는 아니지만 더 세부적인 작업이 가능하기 때문에 사용을 한다.
    필터단독으로 분석기를 사용할 수 없고 반드시 토크나이저가 있어야한다.
  ```
  `캐릭터 필터와 토큰 필터`
  ```
    캐릭터 필터
    캐릭터 필터는 토크나이저 작업 전 문자들의 전처리하는 역할을 하는데, 주로 특정 문자가 왔을 때 다른 문자로 변환시키는 작업을 수행한다.

    엘라스틱 서치에서 제공하는 대부분의 분석기는 캐릭터 필터가 포함되어있지않다.


    토큰필터
    토큰필터는 토큰화되어있는 문자들에 필터를 적용하는 역할을한다.

    토큰들을 변경하거나 삭제하는 작업이 가능하다.

    lowercase, stemmer, stop 등의 토큰 필터가 자주 사용된다.
  ```
#  
# Chapter 4
## 엘라스틱 서치 검색
  ```
    엘라스틱 서치에서 텍스트, 숫자, 정형 or 비정형 데이터를 저장한 후
    인덱싱을 마치면 바로 쿼리를 실행하여 결과를 얻을 수 있다.

    관계형 db에서 like절같은 단순 텍스트 매칭 기법을 넘어 텍스트를 변형하여 검색할 수 있고,
    스코어링 알고리즘을 적용하여 연관성이 높은 결과에 대한 제어가 가능하므로

    대량의 데이터를 대상으로 빠르고 정확한 검색이 가능해진다.
  ```
#  
  `쿼리 컨텍스트와 필터 컨텍스트`
  ```
    과거의 엘라스틱 서치의 검색은 쿼리 컨텍스트와 필터 컨텍스트로 구분되었다.

    - 쿼리컨텍스트
      질의에 대한 유사도를 계산하여 이를 기준으로 더 정확한 결과 도출
      연관성을 계산하여 최대한 비슷한 도큐먼트들을 반환

    - 필터컨텍스트
      유사도를 계산하지않고 일치 여부에 따른 결과값만을 반환
      쉽게 이해하여 일치하는지 아닌지 예 / 아니오 로 구분하여 반환
  ```
  - ![elk4](https://github.com/pnci1029/TIL/assets/81909140/751aa44c-e3ca-4f3d-9ae6-ba2adaffa18c)

  `쿼리 컨텍스트 실행`
  ```
    GET sample_data/_search
    {
      "query" : {
        "match" : {
          "category" : "clothing"
        }
      }
    }

    * clothing 이라는 용어를 category 필드의 역인덱스 테이블에서 조회하여
      가장 연관도가 높은 순으로 정렬되어 조회됨

  - 필터 컨텍스트
   
  ```

  `필터 컨텍스트 실행`
  ```
   GET sample_data/_search
    {
      "query" : {
        "bool" : {
          "filter" : {
            "term" : {
              "day_of_week": "Friday"
            }
          }
        }
      }
    }
    * 연관도와 관련없이 검색하는 용어와 일치하는 도큐먼트 조회
```
#  
### 쿼리스트링과 쿼리DSL
  ```
    엘라스틱 서치에서 쿼리를 사용하는 방법은 쿼리스트링과 쿼리DSL 두 가지가 있다.

    쿼리스트링은 한 줄 정도의 간단한 쿼리에 사용하고
    쿼리DSL은 한줄에 넣기 힘든 복잡한 쿼리에 사용한다.

    쿼리DSL은 엘라스틱 서치에서 제공하는 쿼리 전용 언어로, JSOn 기반의 직관적인 언어이다.

    간단한 조건에 대한 검색은 쿼리스트링으로 충분하지만, 복잡한 논리조건이나 코드수준에서는 쿼리 DSL을 사용하는것이 좋다.
  ```
  `쿼리스트링`

  - <img width="1707" alt="스크린샷 2023-08-02 오후 10 24 08" src="https://github.com/pnci1029/TIL/assets/81909140/4a2c61b0-9b8c-47e9-996d-302ef6abe3f4">

  ```
    샘플데이터 중 customer_full_name값이 mary인 조건처럼
    간단한 검색을 할 때 유용하다.

    검색 코드가 한눈에 파악이 가능하여 가독성이 좋지만 모든 쿼리를 쿼리스트링으로 조회하면 가독성이 떨어질것이다.
  ```
  `쿼리DSL`

  - <img width="1719" alt="스크린샷 2023-08-02 오후 10 27 59" src="https://github.com/pnci1029/TIL/assets/81909140/d4b37ae8-d406-4b31-be13-bf8f1a6abe75">

  ```
    쿼리스트링과 같은 결과값을 나타낸다.

    언뜻보면 쿼리스트링보다 작성해야할 코드나 복잡해보이지만,

    더 복잡한 코드에서 가독성이 증가하고 특히 키바나 콘솔에서 자동완성이나 사용자 오타도 확인이 가능하다.
  ```

#  
#  
#  
#  
#  
#  
#  
refered by (https://velog.io/@yukina1418/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-Elasticsearch%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC,
https://velog.io/@koo8624/Database-Elastic-Search-1%ED%8E%B8-%EC%97%AD%EC%83%89%EC%9D%B8Inverted-Index%EA%B3%BC-%ED%98%95%ED%83%9C%EC%86%8C-%EB%B6%84%EC%84%9D,
https://esbook.kimjmin.net/06-text-analysis/6.7-stemming/6.7.2-nori,
https://www.elastic.co/kr/blog/arirang-analyzer-with-elasticsearch,
https://gong-story.tistory.com/13, 
https://hanamon.kr/elasticsearch-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-nori-%ED%98%95%ED%83%9C%EC%86%8C-%EB%B6%84%EC%84%9D%EA%B8%B0-%EA%B2%80%EC%83%89-%EA%B3%A0%EB%8F%84%ED%99%94-%EB%B0%A9%EB%B2%95/, 
https://bitbucket.org/eunjeon/mecab-ko-dic/src/master/,



)






