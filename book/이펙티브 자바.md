`23. 11. 14 화`
```
  아이템8

  finalizer와 cleane를 피하라

  자바에서 제공하는 두 가지 객체 소멸자중 하나인 finalizer는 상황에 따라 위험할 수 있고 예측할 수 없기 떄문에
  일반적으로 불필요하다.

  cleaner역시 finalizer보다 덜 위험하지만 여전히 예측할 수 없고, 느리다.

  1. 두 객체 소멸자는 즉시 수행된다는 보장이 없다.
  - 두 소멸자가 제때 실행되어야 하는 작업은 절대 할 수 없다.
  - 상태를 영구적으로 수정하는 작업에서는 절대 소멸자에 의존해서는 안 된다.

  2. 심각한 성능 문제를 동반한다.

  3. 심각한 보안 문제를 일으킬 수 있다.
  
```
`23. 11. 16 목`
```
  3장 모든 객체의 공통 메서드

  Object는 객체를 만들 수 있는 클래스지만 기본적으로 상속해서 사용하도록 설계뙤었다.

  Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는
  모두 재정의를 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어있다.

  이 규약들을 잘못 구현하면 대상 클래스(HashMap, HashSet)를 오작동하게 만들 수 있다.

```
`23. 11. 17 금`
```
  4장 클래스와 인터페이스

  아이템 15 클래스와 멤버의 접근 권한을 최소화하라

  어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는
  바로 클래스 내부 데이터와 구현 정보를 외부로부터 얼마나 살 숨겼느냐이다.

  잘 설계된 컴포넌트는 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.

  오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 개의치 않는다.

  정보 은닉, 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.

  정보 은니의 장점은 정말 많은데, 그중 대부분은
  시스템 구성 컴포넌트들을 독립시켜서 개발, 테스트, 최적화, 적용 분석, 수정을
  개별적으로 처리할 수 있게 해주는것과 연관이 있다.

  1. 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
  2. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하며 디버깅할 수 있고 교체에 부담도 적기 때문이다.
  3. 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
  4. 소프트웨어의 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면
  그 컴포넌트와 함께 개발죄지 않은 낯선 환경에서도 사용 가능성이 높기 때문이다.
  5. 큰 시스템을 제작하는 난이도를 낮춘다. 시스템 전체가 완성되지 않아도 개별 컴포넌트 동작을 검증할 수 있기 때문이다.

23. 11. 20 월

  기본 원칙은 간단하다. 모든 클래스와 멤버의 접근성을 가능한 좁혀야한다.

  패키지 외부에서 쓸 이유가 없다면 private으로 선언한다.
  그러면 API가 아닌 내부 구현이 언제든지 수정이 가능하다.

  반면에 public으로 선언을 해준다면 API가 되므로 하위 호환을 위해 영원히 관리를해야한다.

  1. private - 멤버를 선언한 톱레벨 클래스에서만 접근이 가능하다.
  2. package-private - 멤버가 소속된 패키지 안의 모든 클래스에서 접근이 가능하다.
  3. protected - package-private의 접근 범위를 포함하며 이 멤버를 선언한 하위 클래스에서도 접근할 수 있따.
  4. public - 모든곳에서 접근할 수 있다.

* 정리
  프로그램 요소의 접근성은 가능한 한 최소한으로 하자.
  꼭 필요한 것만 골라 최소한의 API를 설계해야한다.

  그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API에 공개되는 일이 없어야 한다.

  public클래스의 상수 public staic final 필드 외에는 어떠한것도 public이 되어서는 안된다.
  public static final 필드가 참조하는 객체가 불변인지 확인하라.
  
```
`23. 11. 21 화`
```
  아이템 16 변경 가능성을 최소화하라

  불변 클래스란 인스턴스 내부 값을 수정할 수 없는 클래스다.

  불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴지는 순간까지 절대 달라지지 않는다.
  자바 플랫폼 라이브러리에도 다양한 불변 클래스가 있다.
  String,  BigInteger, BigDecimal, 기본 타입의 박싱된 클래스등이 여기 속한다.

  이 클래스들을 불변으로 설계한 데는 그럴만한 이유가 있다.
  불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.

```
`23. 11. 22 화`
```
  아이템 17 변경 가능성을 최소화하라

  클래스를 불변으로 만들어야 하는 이유는 위에 있다.

  그렇다면 클래스를 불변으로 만드는 원칙이 있을까?

  클래스를 불변으로 만들려면 다음 다섯가지 규칙을 따르면 된다.

  1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
  2. 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다.
    - 상속을 막는 대표적인 방법은 클래스를 final로 선언하는 것이지만 다른방법도 존재한다.
  3. 모든 필드를 Final로 선언한다.
    - 시스템이 강제하는 수단을 이요하여 설계자의 의도를 명확히 드러내는 방법이다.
  4. 모든 필드를 private으로 선언한다.
    - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을막아준다.
  5. 자신 외에는 내부 가변 컴포넌트에 접근할 수 없도록 한다.


  23. 11. 24 금

  또한
  1. 불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다.
    - 여러 스레드가 동시에 사용하더라도 절대 훼손되지 않는다.
    - 사실 클래스를 스레드 안전하게 만드는 가장 쉬운방법이기도 하다.
    - 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변객체는 안심하고 공유할 수 있.

  2. 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
  3. 값이 바뀌지 않는 구성요소로 이뤄진 객체이기 때문에 맵이나 집합의 원소로 쓰기에 안성맞춤이다.
    맵이나 집합은 안에 담긴 값이 바뀌면 불변식이 허물어지는데, 불변 객체를 사용하면 그런 걱정은 할 필ㅇ가 없다.
  4. 불변 객체는 그 자체로 실패원자성을 제공한다.
    - 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.

  반면 단점도 있다.

  불변 클래스는 값이 다르면 반드시 독립된 객체로 만들어야한다.
  값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치뤄야 한다.


  * 정리

  게터가 있다고 해서 무조건 세터를 만들지는 말자.
  클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

  불변 클래스는 장점이 많으며, 단점이라곤 특정 상황에서의 잠재적 성능 저하 뿐이다.

  모든 클래스를 불변으로 만들수는 없다.
  불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.

  객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  그러니 꼭 변경해야 할 필드를 제외하고는 final로 선언하자.

  다른 합당한 이유가 없ㄷㅇ면 모든 필드는 private final 이어야 한다.
```
`23. 11. 27 월`
```
  아이템 18 상속보다는 컴포지션을 사용하라


  여기서의 상속은 클래스가 다른 클래스를 확장하는 구현 상속을 말한다.
  클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장하는 상속과는 무관하다.

  상속은 코드를 재사용하는 강력한 수단이지만 항상 최선은 아니다.

  일반적인 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
  상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.

  * 정리

  상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
  삭속은 상위 클래스와 하위 클래스가 순수한 is-a관계일때만 써야한다.
  is-a 관계일 때도 안심할 수 없는 게, 하위 클래스의 패키지가 상위 클래스와 다르고,
  상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.

  상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
  특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.
  래퍼 클래스는 하위 클래스보다 견고하고 강력하다.
```
`23. 11. 29 수`
```
  아이템20 추상 클래스보다는 인터페이스를 우선하라

  자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스 이렇게 두 가지다.

  둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는
  반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다

  자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데
  커다란 제약을 안게 되는 셈이다.

  반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면
  다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

  * 정리

  일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
  복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 고려해보자.

  골격 구현은 가능한 한 인터페이스의 디필토 메서드로 제공하여
  그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다.

  가능한 한 이라고 책에서 기술한 이유는 인터페이스에 걸려 있는 구현상의 제약 때문에
  골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 떄문이다.
```
  (https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item18.java)
#  
`23. 12. 04 월`
```
  아이템 21 인터페이스는 구현하는 쪽을 생각하여 설계해라

  자바 8 이전에는 인터페이스에 메서드를 추가할 방법이 없었다.

  인터페이스에 메서드를 추가하면 보통 컴파일 오류가 났다.

  자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만 위험이 완전히 사라진 것은 아니다.

  디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후
  디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.

  자바 라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 상황에서 잘 작동한다.
  하지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.

  디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.

  핵심은 디폴트 메서드라는 도국 ㅏ생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.
```
`23. 12. 05 화`
```
  아이템 22 인터페이스는 타입을 정의하는 용도로만 사용하라

  인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.

  다르게 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를
  클라이언트에 이야기 해주는 것이다.

  인터페이스는 오직 이 용도로만 사용해야 한다.

  이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있다.
  상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다.

  상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.

  클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다.
  따라서 상수 인터페이스를 구혀낳느 ㄴ것은 이 내부 구현을 클래스의 API로 노출하는 행위이다. 
```
(https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item22.java)
#  
`23. 12. 06 수`
```
  아이템 23 태그 달린 클래스보다는 클래스 계층구조를 활용하라

  태그 달린 클래스란 클래스가 어떤 타입인지에 대한 정보를 담고 있는 멤버변수를 의미한다.
  예제의 클래스는 원과 사각형에 대한 정보를 담고있는 멤버변수를 가지고 있다.

  태그달린 클래스는 장확하고, 오류를 발생시키고 비효율적이다.

  따라서 태그 달린 클래스는 계층구조 클래스로 변환해야한다.
  태그 값에 따라 동작이 달라지는 메서드들을 추상 메서드로 선언하고
  일반 메서드로 추가한다.

  
```
(https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item23.java)
#  
`23. 12. 07 목`
```
  아이템 24 멤버 클래스는 되도록 static으로 만들어라

  중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다.
  중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그외의 쓰임새가 있다면 톱 레벨 클래스로 만들어야한다.

  중첩 클래스의 종류는 정적멤버클래스, 멤버 클래스, 익명클래스, 지역 클래스 이렇게 네 가지다.

  이중 첫 번째를 제외한 나머지는 내부 클래스에 해당한다.

  1. 정적 멤버 클래스
  정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고
  일반 ㅡㅋㄹ래스와 똑같다.

  정적 멤버 클래스와 비정적 멤버 클래스의 차이는 단지 static이 붙어 있고 없고 뿐이지만 의미상으로 차이가 크다.

  멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.
  static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다.

  * 정리
  중첩 클래스에는 네 가지가 있으며 각각의 씅미이 다르다.
  메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만든다.

  멤버 클래스의 인스턴스가 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않다면 정적으로 만들자.

  
```
`23. 12. 11 월`
```
  아이템 25 톱레벨 클래스는 한 파일에 하나만 담으라

  소스파일 하나에는 반드시 톱레벨 클래스(톱레벨 인터페이스)를 하나만 담자.
  한 클래스에 대한 정의를 여러 개 만들어 내는 일이 사라질 것이다.

  소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작 방식이 바뀌는 일은 없을 것이다.
```
`23. 12. 12 화`
```
  5장 제네릭

  제네릭은 자바 5 이후로 사용할 수 있다.
  제네릭이 지원하지 않았던 시절에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야했다.

  반면 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다.
  그에 따라 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단한다.


  아이템 26 로(raw) 타입은 사용하지 말라

  
```
#
`용어 정리`
|한글 용어|예시|
|------|---|
|매개변수화 타입|List<String>|
|실제 매개변수 타입|String|
|제네릭 타입|List<E>|
|정규 타입 매개변수|E|
|비한정적 와일드카드|List<?>|
|로 타입|List|
|한정적 타입 매개변수|<T extends Comparable<T>>|
|한정적 와일드 카드 타입|List<? extends Number>|
|제네릭 메서드|static <E> List<E> asList(E[] a)|
|타입 토큰|String.class|
#  
`23. 12. 14 목`
```
  아이템 28 배열보다는 리스트를 사용하라

  배열과 제네릭 타입에는 중요한 차이가 있다.

  제네릭은 불공변이고 배열은 공변이다.

  공변은 실체화되는 반면 불공변은 타입 정보가 소거된다.
  그 결과 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않다.

  제네릭은 그 반대이다.
  그래서 둘을 섞어 쓰기란 쉽지않다.

  둘을 섞어쓰다가 컴파일 오류나 경고를 만난다면, 가장 먼저 배열을 리스트로 대체하도록 하자.
  
```
`23. 12. 18 월`
```
  아이템 29 이왕이면 제네릭 타입으로 만들어라

  클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.
  그러니 새로운 타입을 설계할 떄는 형변환 없이도 사용할 수 있도록 하라.

  그렇게 하기 위해서는 제네릭 타입으로 만들어야 할 경우가 많다.
  클라이언트에 영향을 주지 않으면서 사용자가 편하게 사용할 수 있도록 하는 길이다.
```
(https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item29.java)
#

`23. 12. 19 화`
```
  아이템 30 이왕이면 제네릭 메서드로 만들라

  클래스와 마찬가지로 메서드도 제네릭으로 만들 수 있다.

  제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을
  명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기 쉽다.

  타입과 마찬가지로 메서드도 형변환 없이 사용할 수 있는 편이 좋으며,
  많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다.
```
(https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item30.java)
#  
`23. 12. 20 수`
```
  6장 열거타입과 어노테이션

  자바에는 특수한 목적의 참조 타입이 두 가지 있다.

  하나는 클래스의 일종인 열거타입(enum)이고,
  다른 하나는 인터페이스의 일종인 어노테이션이다.

  
```
`23. 12. 21 목`
```
  아이템 34 int상수 대신 열거 타입을 사용하라

  정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.
  평범한 상수를 나열한 것 뿐이라 컴파일 하면 그 값이 클라이언트 파일에 그대로 새겨진다.
  따라서 상수의 값이 바뀌면 클라이언트도 반드시 다시 컴파일해야한다.

  이런 문제들을 해결하기 위해 자바에서는 열거타입을 지원한다.
  열거 타입 그 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만든다.

  열거 타입으로 만들어진 인스턴스들을 딱 하나씩만 존재함이 보장된다.
  싱글턴은 원소가 하나뿐인 열거 타입이라 할 수 있고, 열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있다.

  * 열거 타입은 확실히 정수 상수보다 뛰어나다.
  더 읽기 쉽고 안전하다.

  대다수 열거 타입이 명시적 생성자나 메서드 없이 쓰이지만, 각 상수를 특정 데이터와 연결짓거나
  상수마다 다르게 동작하게 할 때 필요하다.

```
(https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item34.java)
#  
`23. 12. 22 금`
```
  아이템 35 ordinal 메서드 대신 인스턴스 필드를 사용하라
  
```
(https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item35.java)
#  
`23. 12. 26  화`
```
  아이템 36 비트 필드 대신 EnumSet을 활용하라

  열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도
  비트 필드를 사용할 이유는 없다.

EnumSet클래스가 비트 필드 수준의 명료함과 성능을 제공하고
열거 타입의 장점까지 선사하기 때문이다.
  
```
(https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item36.java)
#  
`23. 12. 27 수`
```
  아이템 38 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

  열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을
  함께 사용해 같은 효과를 낼 수 있다.

  이렇게 하면 클라이언트는 이 인터페이스를 구현해 자신만의 열거타입을 만들 수 있다.

  그리고 API가 인터페이스 기반으로 작성되었다면 기본 열거 타입의
  인스턴스가 쓰이는 모든 곳을 새로 확장한 열거 타입의 인스턴스로 대체해 사용할 수 있다.
```
`23. 12. 28 목`
```
  아이템 39 명명패턴보다 애너테이션을 사용하라

  프레임워크가 다뤄야 할 피로그램 요소는 구분되는 명명패턴으로 적용해왔다.

  예를들어 테스트 프레임워크인 JUNIT은 이름을 test로 시작하게끔했다.
  효과적인 방법이지만 단점도 크다.

  1. 오타가 나면 안된다.
  테스트 이름을 tset이라고 지으면 JUnit은 이 메서드를 무시하고 지나치기 때문에 통과했다고 생각할 수 있다.

  2. 올바른 프로그램 요소에만 사용되리라 보장할 수 없다.
  위와 마찬가지로 JUnit은 경고 메세지 조차 출력하지 않지만 개발자가 의도한 테스트는 전혀 수행되지 않는다.

  3. 프로그램 요소를 매개변수로 전달할 방법이 없다.
  특정 예외를 던져야 성공하는 케이스가 있다고 할 때
  개디하는 예외타입에 일치하는 매개변수를 던져야하는데 매개변수를 추가할 방법이 없다.

  위 단점들을 해결해주는 개념이 애너테이션이다.

  Junit4부터도 애너테이션을 통해 위 문제들을 해결했다.
```
