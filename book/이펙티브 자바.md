`23. 11. 14 화`
```
  아이템8

  finalizer와 cleane를 피하라

  자바에서 제공하는 두 가지 객체 소멸자중 하나인 finalizer는 상황에 따라 위험할 수 있고 예측할 수 없기 떄문에
  일반적으로 불필요하다.

  cleaner역시 finalizer보다 덜 위험하지만 여전히 예측할 수 없고, 느리다.

  1. 두 객체 소멸자는 즉시 수행된다는 보장이 없다.
  - 두 소멸자가 제때 실행되어야 하는 작업은 절대 할 수 없다.
  - 상태를 영구적으로 수정하는 작업에서는 절대 소멸자에 의존해서는 안 된다.

  2. 심각한 성능 문제를 동반한다.

  3. 심각한 보안 문제를 일으킬 수 있다.
  
```
`23. 11. 16 목`
```
  3장 모든 객체의 공통 메서드

  Object는 객체를 만들 수 있는 클래스지만 기본적으로 상속해서 사용하도록 설계뙤었다.

  Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는
  모두 재정의를 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어있다.

  이 규약들을 잘못 구현하면 대상 클래스(HashMap, HashSet)를 오작동하게 만들 수 있다.

```
`23. 11. 17 금`
```
  4장 클래스와 인터페이스

  아이템 15 클래스와 멤버의 접근 권한을 최소화하라

  어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는
  바로 클래스 내부 데이터와 구현 정보를 외부로부터 얼마나 살 숨겼느냐이다.

  잘 설계된 컴포넌트는 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.

  오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 개의치 않는다.

  정보 은닉, 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.

  정보 은니의 장점은 정말 많은데, 그중 대부분은
  시스템 구성 컴포넌트들을 독립시켜서 개발, 테스트, 최적화, 적용 분석, 수정을
  개별적으로 처리할 수 있게 해주는것과 연관이 있다.

  1. 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
  2. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하며 디버깅할 수 있고 교체에 부담도 적기 때문이다.
  3. 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
  4. 소프트웨어의 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면
  그 컴포넌트와 함께 개발죄지 않은 낯선 환경에서도 사용 가능성이 높기 때문이다.
  5. 큰 시스템을 제작하는 난이도를 낮춘다. 시스템 전체가 완성되지 않아도 개별 컴포넌트 동작을 검증할 수 있기 때문이다.

23. 11. 20 월

  기본 원칙은 간단하다. 모든 클래스와 멤버의 접근성을 가능한 좁혀야한다.

  패키지 외부에서 쓸 이유가 없다면 private으로 선언한다.
  그러면 API가 아닌 내부 구현이 언제든지 수정이 가능하다.

  반면에 public으로 선언을 해준다면 API가 되므로 하위 호환을 위해 영원히 관리를해야한다.

  1. private - 멤버를 선언한 톱레벨 클래스에서만 접근이 가능하다.
  2. package-private - 멤버가 소속된 패키지 안의 모든 클래스에서 접근이 가능하다.
  3. protected - package-private의 접근 범위를 포함하며 이 멤버를 선언한 하위 클래스에서도 접근할 수 있따.
  4. public - 모든곳에서 접근할 수 있다.

* 정리
  프로그램 요소의 접근성은 가능한 한 최소한으로 하자.
  꼭 필요한 것만 골라 최소한의 API를 설계해야한다.

  그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API에 공개되는 일이 없어야 한다.

  public클래스의 상수 public staic final 필드 외에는 어떠한것도 public이 되어서는 안된다.
  public static final 필드가 참조하는 객체가 불변인지 확인하라.
  
```
`23. 11. 21 화`
```
  아이템 16 변경 가능성을 최소화하라

  불변 클래스란 인스턴스 내부 값을 수정할 수 없는 클래스다.

  불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴지는 순간까지 절대 달라지지 않는다.
  자바 플랫폼 라이브러리에도 다양한 불변 클래스가 있다.
  String,  BigInteger, BigDecimal, 기본 타입의 박싱된 클래스등이 여기 속한다.

  이 클래스들을 불변으로 설계한 데는 그럴만한 이유가 있다.
  불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.

```
`23. 11. 22 화`
```
  아이템 17 변경 가능성을 최소화하라

  클래스를 불변으로 만들어야 하는 이유는 위에 있다.

  그렇다면 클래스를 불변으로 만드는 원칙이 있을까?

  클래스를 불변으로 만들려면 다음 다섯가지 규칙을 따르면 된다.

  1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
  2. 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다.
    - 상속을 막는 대표적인 방법은 클래스를 final로 선언하는 것이지만 다른방법도 존재한다.
  3. 모든 필드를 Final로 선언한다.
    - 시스템이 강제하는 수단을 이요하여 설계자의 의도를 명확히 드러내는 방법이다.
  4. 모든 필드를 private으로 선언한다.
    - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을막아준다.
  5. 자신 외에는 내부 가변 컴포넌트에 접근할 수 없도록 한다.


  23. 11. 24 금

  또한
  1. 불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다.
    - 여러 스레드가 동시에 사용하더라도 절대 훼손되지 않는다.
    - 사실 클래스를 스레드 안전하게 만드는 가장 쉬운방법이기도 하다.
    - 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변객체는 안심하고 공유할 수 있.

  2. 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
  3. 값이 바뀌지 않는 구성요소로 이뤄진 객체이기 때문에 맵이나 집합의 원소로 쓰기에 안성맞춤이다.
    맵이나 집합은 안에 담긴 값이 바뀌면 불변식이 허물어지는데, 불변 객체를 사용하면 그런 걱정은 할 필ㅇ가 없다.
  4. 불변 객체는 그 자체로 실패원자성을 제공한다.
    - 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.

  반면 단점도 있다.

  불변 클래스는 값이 다르면 반드시 독립된 객체로 만들어야한다.
  값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치뤄야 한다.


  * 정리

  게터가 있다고 해서 무조건 세터를 만들지는 말자.
  클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

  불변 클래스는 장점이 많으며, 단점이라곤 특정 상황에서의 잠재적 성능 저하 뿐이다.

  모든 클래스를 불변으로 만들수는 없다.
  불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.

  객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  그러니 꼭 변경해야 할 필드를 제외하고는 final로 선언하자.

  다른 합당한 이유가 없ㄷㅇ면 모든 필드는 private final 이어야 한다.
```
`23. 11. 27 월`
```
  아이템 18 상속보다는 컴포지션을 사용하라


  여기서의 상속은 클래스가 다른 클래스를 확장하는 구현 상속을 말한다.
  클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장하는 상속과는 무관하다.

  상속은 코드를 재사용하는 강력한 수단이지만 항상 최선은 아니다.

  일반적인 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
  상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.

  * 정리

  상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
  삭속은 상위 클래스와 하위 클래스가 순수한 is-a관계일때만 써야한다.
  is-a 관계일 때도 안심할 수 없는 게, 하위 클래스의 패키지가 상위 클래스와 다르고,
  상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.

  상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
  특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.
  래퍼 클래스는 하위 클래스보다 견고하고 강력하다.
```
`23. 11. 29 수`
```
  아이템20 추상 클래스보다는 인터페이스를 우선하라

  자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스 이렇게 두 가지다.

  둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는
  반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다

  자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데
  커다란 제약을 안게 되는 셈이다.

  반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면
  다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

  * 정리

  일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
  복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 고려해보자.

  골격 구현은 가능한 한 인터페이스의 디필토 메서드로 제공하여
  그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다.

  가능한 한 이라고 책에서 기술한 이유는 인터페이스에 걸려 있는 구현상의 제약 때문에
  골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 떄문이다.
```
  (https://github.com/pnci1029/mypro/blob/master/bookPrac/src/main/java/com/study/bookprac/part2/Item18.java)
#  
`23. 12. 04 월`
```
  아이템 21 인터페이스는 구현하는 쪽을 생각하여 설계해라

  자바 8 이전에는 인터페이스에 메서드를 추가할 방법이 없었다.

  인터페이스에 메서드를 추가하면 보통 컴파일 오류가 났다.

  자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만 위험이 완전히 사라진 것은 아니다.

  디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후
  디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.

  자바 라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 상황에서 잘 작동한다.
  하지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.

  디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.

  핵심은 디폴트 메서드라는 도국 ㅏ생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.
```
`23. 12. 05 화`
```
  아이템 22 인터페이스는 타입을 정의하는 용도로만 사용하라

  인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.

  다르게 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를
  클라이언트에 이야기 해주는 것이다.

  인터페이스는 오직 이 용도로만 사용해야 한다.

  이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있다.
  상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다.

  상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.

  클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다.
  따라서 상수 인터페이스를 구혀낳느 ㄴ것은 이 내부 구현을 클래스의 API로 노출하는 행위이다. 
```
