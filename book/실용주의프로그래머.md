`23.08.08 화`
```
  ~ 1장 끝

  4. 지식포트폴리오
    지식에 대한 투자는 언제나 큰 이윤을 남긴다.
    그러나 이 지식은 불행히도 오래가지못한다.

    개발자에게 오늘 배운 기술은 내일 구형기술이 될 수 있고 매몰된 기술로 금방 돌아설수있다.

    그래서 컴퓨터, 애플리케이션, 도메인등 알고있는 사실들을 지식포트폴리오로 일종의 투자포트폴리오 형식으로 관리를 해볼수있다.

     주기적으로 대각화된 학습을 통해 지식포트폴리오를 쌓을 수 있다.
    1) 매년 새로운 언어를 배워봐라
    2) 기술서적을 한달에 한권씩 읽어보자
    3) 기술 서적이 아닌 책도 읽어라
    4) 수업을 들어라
    5) 여러모임에 참여하라
    6) 다른 운영체제 환경에서도 실험해봐라

  또한 비판적 사고를 가져본다
    1) 왜냐고 5번묻기
    2) 누구에게 이익이될까?
    3) 어떤 맥락일까?
    4) 언제 어디서 효과가 있을까?
    5) 왜 문제가 되는가?
```
`23.08.14 월`
```
  안읽음
```
`23.08.17 목`
```
  직교성

  개발측면에서 직교성이란 결합도와 관련이있다.
  여러 컴포넌트들간에 영향도나 관련없는 코드들간의 영향을 의미한다.

  단일하고 잘 정의된 컴포넌트 즉 직교적인 시스템을 작성했을때는 아레와 같은 장점들이 있다.

  1. 생산성 향상
    - 작은 컴포넌트들의 단위를 여러개 만드는게 거대한 컴포넌트를 만드는것보다 유지보수와 생산성 측면에서 우수하다
    - 독립적으로 정의된 작은 컴포넌트들을 잘 결합한다면 더 큰 생산성을 일으킬 수 있다.

  2. 리스크 감소
    - 독립적인 시스템에서 A가 장애가 나더라도 B, C에 영향을 주지않기 때문에 전체 시스템이 무너지지않는다.

  직교적인 시스템을 개발하려면 어떤 방법으로 개발할 수 있을까?

    1. 전역데이터를 피하라

    2. 불필요한 코드들을 외부 모듈에 노출을 자제하라(부끄럼쟁이 코드를 작성하라)

    3. 유사한 함수 생성을 피하라



  가역성

  유일한 답이 있는 문제라도 여러 답을 내놓아라

  MySQL을 초기에 사용하기로 하고 프로젝트를 진행하다가
  PostGreSQL로 사용하기로 변경되었다.
  이런상황에서 모든 코드들을 바꿔야한다면 설계가 잘못된것이다.

  웹브라우저 어플리케이션을 모바일 앱으로 전환한다고했을때
  이상적인 상황은 서버쪽에서는 큰 변화가 없어야한다
  클라이언트에서 HTML을 API로 대체하기만 하면될것이다.



  예광탄

  거대한 프로젝트를 시작할때 처음 백지상태에서 어떻게 시작해야할지 감도 안온다.

  그럴때 예광탄을 목표물을 향해쏘는것이다.

  요구사항에서 필요한 아주 일부분만 클라이언트 - 서버까지 개발을하고 그 이후에 살을 붙이는 것을 말한다.

  이러한 가벼운 개발방법론이 프로토타입 개발방법론과 비교를하자면
  프로토타입은 개발 후 다 삭제 후 새로 코드를 작성해 개발하는 반면
  예광탄은 그 코드들을 유지한채 더 살을 키워가는것을 의미한다.

```
`23.08.18 금`
```
  프로토타입

  그렇다면 프로토타입은 어떤 상황에서 사용하는것이고 개발적인 측면에서의 프로토타입이란 무엇일까?
  다양한 산업군에서도 사용하는 프로토타입은 실제 제품보다 저렴하게 만들 수 있고 여러가지 역학, 구조적 특징들을 미리 살펴보기 위함이 크다.

  소프트웨어에서의 프로토타입도 위험요소를 미리 분석 후 저렴한 비용으로 이를 바로잡는 것이다.

  프로토타입은 몇가지 제한사항에 답변을 위해 만들어지면 되며
  실제 사용자에게 중요한 세부사항이더라도 일단은 무시하고 개발할 수 있다.

  프로토타입의 대상은 무엇인가? 위험요소이다.
  이전에 해 본적 없는것, 증명되지 않았고 실험적인것, 의심이 가는것들이 모두 프로토타입 대상이 될 수 있다.

  겉으로 좋아보이는 프로토타입을 실제로 사용할 수는 없다.
  그것은 단지 프로토타입이기 때문이다.

  나무와 테이프로 멋진차를 만들 수 있지만 퇴근길에 나무차를 타고 갈 수 없듯 말이다.

  작업 환경이나 문화가 프로토타입 제품을 취하하기 어렵다면 처음부터 예광탄으로 시작하는것이 나을것이다.


  도메인언어


  추정

  업무적인 대화에서 기획이든 배포든 개발이든 테스트든 추상적으로 대답해야할 생황이 자주 생긴다.

  130일정도 소요될거같다. 라고 하면 어느정도인지 추정하기 어렵다.
  이를 대략 6개월정도 소요된다. 라고 하면 위 설명보다 알아듣기 쉬울것이다.

  상황과 목적과 상대방에 따라 추정값을 해석하여 이야기하는것이 중요하다.
  
```
`23.08.21 월`
```
  버전관리

  이미 개발을 하고 있는사람들에게는 매우 익숙하겠지만
  처음 개발을 접하거나 타 IT업무를 처리하다보면 undo의 기능이 매우 중요하다.

  지금 당장 혹은 몇시간 전에 일들은 undo 처리가 가능하지만
  몇 주 전의 상태로 돌리고 싶다면 실행취소로 처리할 수 없다.

  이런것들이 VCS(version control system)를 사용하는 이유중 하나이다.

  VCS는 단순히 버전관리 외에도 해당 소스코드를 누가 언제 수정했는지, 어떤이유에서 수정했는지 간접적인 추론도 가능하다.
  특정 릴리즈로 돌아가 해당 릴리즈를 재생산해 낼 수 있다.

  또한 둘 이상의 작업자가 동시에 작업하는게 가능하다.

  브랜치를 사용하여 서로 격리된 환경에서 두가지 이상의 버전을 만들고, 병합을 통해 프로젝트를 합칠 수 있다.



  디버깅

  디버깅은 단지 문제 풀이일 뿐이라는 사실을 받아들이고, 그런마음으로 해결에 임해야힌디.

  디버깅 사고방식
  
    마감이 임박하거나 의뢰인이나 상사가 코앞에 붙어서 감시를 한다면 더더욱이 당황할 수 밖에 없다.
    그러나 한발짝 뒤로 물러나서 버그라고 생각하는 증상이 무엇인지 원인을 진짜 생각해보는것이 중요하다.

  디버깅 전략

  1. 버그 재현하기
    버그는 거의 대부분 번식해서 늘지않는다.
    버그 해결의 가장 좋은것은 그 버그를 재현하는것이다.
    버그를 재현할 수 없다면, 버그를 고쳤다는것을 어떻게 확인할것인가?

  2. 이진분할
    버그를 해결하기 위해 거대한 스택트레이스를 눈앞에 두고, 검색을 시작한다.
    중간 즈음에서 스택 프레임을 골라 값을 확인하고, 그 값이 정상이면 그 프레임 위를 확인하고
    그 값이 비정상이면 그 프레임 아래를 확인한다.
    이런 방식으로 분할하여 처리를 하면 프레임이  64개가 있더라도 6번 안에 해결이 가능하다.

  3. 고무오리
    매우 단순하지만 꽤 효과적인 방법으로 그냥 누군가에게 문제를 설명하는 방법이 있다.
    상대는 욕조에 있는 고무오리 처럼 아래위로 까닥이면서 듣는다.
    차근차근 설명해 나가는 단순한 행휘 그 자체로 문제 해결에 충분할 때가 있다.

    간단해 보인다.
    하지만 누군가에게 문제를 설명하게 되면 혼자 코드를 살펴볼때는 당연히 여기고 지나갈것을
    명시적으로 이야기해야한다.

```
`23.08.22 화`
```
  엔지니어링 일지

  회의를 할때나 변수값을 적어놓을 때 종이 문서가 아니더라도 일지를 쓰면 좋은점들이 많다.

  1. 기억보다 믿을만하다.

  2. 진행중인 작업과 관련이 없는 발상을 쌓아 놓을 수 있다.

  3. 고무오리와 마찬가지로 누군가에게 이야기하는것과 같은 효과가 발생한다.
```
`23.08.23 수`
```
  4장 실용주의 편집증

  운전자들은 자기 자신만이 훌륭한 운전자라고 생각한다.
  타인은 훌륭한 운전자가 아니기 떄문에 우리들은 방어운전을 한다.

  코딩에서도 비슷한 면이 있다.
  우리는 늘 다른 사람의 코드가 우리 기준에 못 미칠거라고 생각을 하고 처리하고있다.

  그래서 우리는 방어적으로 코딩을 하고, 조금이라도 의심이 들면 모든 정보를 확인한다.
  잘못된 데이터를 찾기 위해 단정문을 사용하고, 데이터베이스 컬럼에 제약을 걸어 체킹하는 정도이다.

  그러나 실용주의 프로그래머는 여기서 한 걸음 더 나간다.
  실용주의 프로그래머는 자기 자신 역시 믿지않는다.

  그렇기 때문에 실용주의 프로그래머는 자기 자신의 실수를 대비한 방어책 역시 마련한다.




```
`23.08.25 금`
```
  1. 계약에 의한 설계

  사람을 대하는 것에 대해 여러운거보단 시스템에 대하는게 쉽지만
  그래도 시스템을 다루는것은 여전히 어렵다.

  지난 수천년간 우리가 사람 사이의 문제를 해결하는 방법을 고안해온것처럼
  컴퓨터 시스템에도 적용할 수 있다.

  계약은 자신과 상대편의 권리 및 책임을 정의한다.
  한쪽이 계약을 어겼을 경우의 대응도 계약 사항에 포함된다.

  소프트웨어 시스템의 모든 함수와 메서드가 수행을 할때 아래의 전제와 선언을 통해 설명한다.

  1. 선쟁 조건:
    루틴이 호출이되기 위해 참이어야 하는 것. 즉 루틴의 요구사항이다.
    루틴의 선행조건이 위반된 경우에는 루틴이 호출되어서는 안 된다.

  2. 후행 조건:
    루틴이 자기가 할 것이라고 보장하는 것. 즉 루틴이 왼료되었을 때의 상태이다.
    루틴에 후행 조건이 있다는 것은 곧 루틴이 종국에는 종료될것이란걸 의미한다.,
    루틴은 무한반복을 허용하지않는다.

  3. 클래스 불변식:
    호출자의 입장에서 이 조건은 언제나 참인 것을 클래스가 보장한다.

  루틴과 그 루틴을 호출하려는 코드간의 계약은 다음과 같다.

  만약 호출자가 루틴의 모든 선행 조건을 충족한다면 해당 루틴은 종료 시
  모든 후행조건과 불변식이 참이 되는 것을 보장한다.



  2. 죽은 프로그램은 거짓말을 하지 않는다.


```
`23.08.28 월`
```
  단정적 프로그래밍

  그런일은 절대 일어날 리 없어 하는 단정적 프로그래밍으로 자신을 기만하지 말자.
  물론 그런 일은 일어나지 않을 거야 라는 생각이 든다면 그런일을 확인하는 코드를 추가하라.



  리소스 사용의 균형

  우리는 메모리, 트랜잭션, 스레드, 네트워크 연결, 파일 등 무한히 사용할 수 없는 자원들을
  균형있게 사용하려고 관리한다.

  리소스들은 예상가능한 패턴을 따르며 우리는 리소스를 할당하고, 사용한 후 해제한다.

  그러나 많은 개발자들이 리소스 사용에 일관된 방침을 갖고있지않다.

  '자신이 시작한 것은 자신이 끝내라'
  이 팁은 리소스를 할당하는 함수가 리소스를 해제하는 책임까지 져야 한다는 뜻이다.
  위 팁은 리소스 관리 외에도 많은 경우 적용이 가능하다.
```
`23.08.30 수`
```
  헤드라이트를 앞서가지 말라

  미래에 대한 예측은 힘들다.
  헤드라이트를 앞서가지 말라는 것은, 투사 거리 만큼 밝힐 수 있는 헤드라이트 범위를 넘어 속력을 내면
  정지거리가 헤드라이트를 앞서게 되어있다.

  개발 관점에서는 우리가 지금 당장 3개월 후 혹은 서비스 런칭 후 까지 예측해서 개발하는것이 위험하다는 의미이다.
  작은단계들을 밟아가며 피드백을 통해 개선해나가는것이다.



  Chapter 5 구부러지거나 부러지거나

  결합도 줄이기

  다리를 건축할때는 모양이 바뀌거나 형태가 변해서는 안된다.
  그런 상황에서는 결합도를 높이는게 중요하나

  우리의 코드는 오늘 작성한 순간 레거시가 되고 이후에 유지보수를 해야할 상황이 많이 생긴다.
  이런 상황에서는 결합도를 최대한 느슨하게 만드는것이 중요하다.


  실세계를 갖고 저글링하기
  사람이 컴퓨터에 맞추기보단 컴퓨터를 우리 세계안으로 들여야한다.

  이벤트란 무언가 정보가 있다는것을 의미한다.
  이 정보는 사용자가 버튼을 클릭하거나 정보가 갱신되었을 때 외부에서 가져올 수도 있다.

  이 이벤트에 잘 반응하기 위해서는 몇가지 전략들이 있다.

  1. 유한기계전략

  2. 감시자패턴
  감시자패턴은 이벤트를 발생시키는 감시대상과 이벤트에 관심이 있는 클라이언트인 감시자로 이루어진다.

  감시자는 자신이 관심 있는 이벤트를 감시 대상으로 등록하고
  나중에 이벤트가 발생하면 등록된 감시자 목록을 보면서 함수들을 일일이 호출한다.

  감시자 패턴에는 문제가 있는데, 모든 감시자가 감시 대상에 등록을 해야하기 떄문에 결합이 생긴다.
  그리고 일반적으로 감시 대상이 콜백을 직접 호출하기 때문에 병목이 생길 수 있다.
  이런 동기적 특성상 감시 대상이 계속 콜백이 끝나기 까지 기다려야하기 때문이다.

  이 문제는 게시-구독 전략으로 해결한다.

  3. 게시-구독패턴
  펍섭이라고 부르는 게시-구독 패턴은 감시자패턴을 일반화한것이다.

  펍섭 모델은 게시자(publisher), 구독자(subscriber)가 있고 이들은 채널을 통해 연결된다.
  채널은 별도의 코드로 구현되며 각 채널에는 이름이 있다.

  구독자는 관심사를 하나 이상의 채널에 등록하고, 게시자는 채널에 이벤트를 보낸다.

  감시자 패턴과 달리 펍섭 통신은 우리 코드 밖에서 일어나며, 대게 비동기적으로 이뤄진다.

  이 모델은 추가적인 결합 없이 비동기 이벤트 처리를 구현하기 좋은 기술이며,
  감시자패턴과 비교하여 펍섭 모델은 공통 인터페이스인 채널을 추상화하여 결합도를 줄여 처리하였다.
```
`23. 08. 31 목`
```
  31. 상속세

  이거만 읽었는데 잘 모르겠음.. 다시 읽을 예정
```

`23. 09. 01 금`
```
  Chapter 6 동시성

  동시성이란 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는것이다.
  병렬성이란 실제로 동시에 실행되는 것이다.
  
  동시성은 소프트웨어의 동시 접근으로 이해으로 이해하고 병렬성은 하드웨어의 동시사용으로 이해를 하면된다.
  
  동시성을 얻으려면 스레드나 프로세스등을 사용하여 실행중에 코드의 다른 부분을 전환할 수 있는 환경으로 구동해야하고
  병렬성을 얻으려면 두 가지 일을 동시에할 수 있는 하드웨어가 필요하다.
  
  동시성이나 병렬성을 지원하는 코드를 개발하기는 어렵다.
  그 이유는 우리가 프로그래밍을 순차적 시스템으로 배웠기 때문이다.
  
  우리가 사용하는 언어의 기능이 순차적으로 사용될 때는 비교적 안전하지만, 두 가지 일이 동시에 일어난다면 골치가 아파진다/.
  가장 큰 문제는 공유 상태이다. 둘 이상의 코드 뭉치가 하나의 변경 데이터를 참조한다면 공유상태가 존재해지는것이다.



  시간적 결합 깨트리기

  우리가 신경써야할 시간은 동시성과 순서이다.
  우리는 프로그래밍할 때 두 측면 모두를 신경쓰지 않는다.

  대게 시간적 결합을 만들어,
  'A메소드 수행 후 B 메소드 수행...' 등
  똑은 딱보다 먼저 일어나야한다.

  이러한 접근 방법은 유연하지 않고, 현실과도 동떨어져 있다.
  그래서 우리는 동시성을 확보해야 한다.

  동시성을 찾는 방법중 하나는 활동 다이어그램을 작성하여 작업 흐름을 기록하는 방법이다.

  예를들어 피나 콜라다 칵테일 제조 로봇용 소프트웨어를 작성한다고 했을 때, 순서는 다음과 같다.

    1. 믹서를 연다.
    2. 피나 콜라다 믹스 병을 연다.
    3. 피나 콜라다 믹스를 믹서에 넣는다.
    4. 화이트 럼 1/2컵을 잰다.
    5. 럼을 믹서에 붓는다.
    6. 얼음을 두 컵 넣는다.
    7. 믹서를 닫는다.
    8. 1분 동안 돌린다.
    9. 믹서를 연다.
    10. 잔을 가져온다.
    11. 우산 장식을 가져온다.
    12. 차려낸다.

  바텐더가 위 방식을 순서대로 진행한다면 금방 실업자가 될것이다.

  우리가 해야할 일은 위 순서에서 병렬적으로 처리할 수 있는 부분을 찾는것이다.


  공유 상태는 틀린 상태

    당신이 가장 좋아하는 레스토랑에 방문했다.
    메인 요리를 모두 먹고 남은 애플파이가 있는지 물어봤다.
    종업원이 진열장을 보고 한 조각이 남아있는 것을 보고 그렇다고 답했다.
    한편 반대쪽에서도 다른 고객이 종업원에게 같은 질문을 하고 있었더.

  두 고객중 한 명은 실망하게 될것이다.

  문제는 상태가 공유된것이다.
  레스토랑의 종업원들은 서로를 고려하지 않고 진열장만 확인했다.

  이를 해결하기 위한 방법으로 세마포어가 있다.
  세마포어는 단순히 한 번에 한 사람만이 가질 수 있는 무언가다.

  레스토랑 예시를 들었을 때 진열장 위 도깨비 인형을 올려서 파이 주문을 받기 전 도깨비 인형을 손에 넣어야 응대를 할 수 있는것이다.

  주로 잠금 / 잠금 해제, 획득 / 반환 등으로 불린다.

  또는 리소스를 트랜젹선으로 관리하는 것도 방법이다.
  
```
`23. 09. 04 월`
```
  칠판

  형사들이 살인 사건을 조사하기 위해 칠판을 어떻게 사용하는지 생각해보자.
  수사과장이 회의실 큰 회의실 칠판을 끌어다 놓고 딱 하나의 문제를 적는다.

  '남성 사고? 살인?'

  형사들마다 단서, 정은, 증거들이 해결에 기여할 것이고
  자료가 쌓이면 어떤 형사가 다른 형사의 단서를 기반으로 연결고리를 찾아내어 추측을 붙이기도 한다.

  칠판 접근방법의 몇 가지 주요 특징은 다음과 같다.
  
    형사들을 다른 형사들의 존재를 알 필요가 없다.
    형사들은 저마다 다른 분야의 훈련과 다른 수준의 학력과 경험을 지녔을 수 있다.
    임무 교대시간도 제각기 다르고 칠판에 제한없이 어떤 것이든 올릴 수 있다.

  우리 프로그래밍에도 동시성으로 처리를 하자면 다음과 같은 문제들을 생각해볼 수 있다.
  
    응답은 정해진 순서 없이 도착한다.
    여러 표준 시간대에 있는 분산된 사람이 데이터를 수집할 수 있다.
    어떤 데이터는 다른 데이터에 의존하기도 한다.
    새로운 데이터가 도착하면 새로운 질문이나 정착을 적용해야 할 수도 있다.

  이런 작업 흐름을 메세지 시스템으로 해결하도록 생각할 수 있다.

  카프카나 NATS같은 메세징 시스템으로 이벤트 로그 형태로 영속성을 제공하고
  패턴 매칭 형태로 메세지를 가져올 수 있다.



  Chapter 7 코딩하는 동안


  파충류의 뇌에 귀 기울이기

  무슨말인지 잘 모르겠음..


```
`23. 09. 06 수`
```
  우연에 맡기는 프로그래밍

  개발을 해야할 일이 생겨서 약간의 코드를 작성한다.
  시험삼아 돌려보니 잘 돌아가서 코드를 조금씩 계속 덧붙인다.

  갑자기 어느순간 잘 돌아가던 코드가 안돌아가서 몇 주 동안 코딩한 프로그램이 돌아갈 낌새도 보이지 않는다.

  코드가 왜 망가졌는지 모르는 이유는 왜 코드가 잘 돌아갔는지도 몰랐기 때문이다.

  어떤 회사에서 진행한 한 대형 프로젝트는 외부에 설치된 다수의 데이터를 수집하여
  보고서를 작성해야 했다.

  미국의 여러 주와 시간대에 걸쳐 설치되어있었는데,
  과거부터 진행되던 레거시 시스템들로 시간대에 대한 해석이 달라
  시간이 딱 한시간만 달랐다.

  작업자들은 딱 한시간이니 괜찮다며 한시간을 더하거나 빼서 계산하는데 익숙해졌다.

  시간을 다루는 근원의 모델이 없어서 말도 안 되는 양의 +1, -1 코드들이 계쏙 생겨났다.

  우리는 따라서 의도엊ㄱ으로 프로그래밍 해야한다.

    내가 지금 무엇을 하고 있는지 알아야 한다.
    경험이 더 적은 프로그래머에게 코드를 상세히 알려줄 수 있는가? 아니라면 우연에 기대고 있는것이다.
    자신도 잘 모르는 코드를 만들지 말라.
    계획을 세우고 그 바탕으로 진행하라
    신뢰할 수 있는것에만 기대라
    가정을 기억으로 남겨라
    과거의 노예가 되지 말아라



  알고리즘의 속도

  개발자들이 직접 알고리즘을 짜는 일은 많이 없지만, 우리가 하는 일이 말이 되는지 가볍게 확인하거나
  또는 상세히 분석해야하는 경우가 있다. 이럴 때 대문자 O 표기법이 유용하다.

  O표기법은 우리가 생각하는 값-시간, 메모리 등 상한을 기술하는 표기법이다.

  O(1) 상수 (배열의 원소 접근, 단순 명령문)
  O(logn) 로그 (이진검색)
  O(n) 선형 (순차검색)
  O(nlogn) 선형보다는 좋지않지만 많이 나쁘지는 않음 (퀵 정렬과 힙 정렬의 평균 수행시간)
  O(n^2) 제곱 (선택 정렬과 삽입 정렬)
  O(n^3) 세제곱 (두 n*n행렬의 곱)
  O(C^n) 지수 (집합 분할 문제)

```

`23. 09. 07 목`
```
  리팩토링

  코드 고쳐쓰기, 다시 작업, 다시 아키텍처 생성 등을 모두 아울러 리스트럭처링이라고 하는데,
  이들 중 일부만 떼어서 리팩토링이라고도 한다.

  리팩토링의 핵심은 밖으로 드러나는 동작은 바뀌지않고, 기능을 추가하는 작업이 아니다 라는 것이다.

  리팩토링을 식물을 다시 심기 위해 정원 전체를 갈아엎듯이 해서는 안된다.


  리팩토링을 해야할 때

    중복 (DRY 원칙 위배 발견 등)
    직교적이지 않은 설계
    더 이상 유효하지 않은 지식(변화된 요구사항, 지식 수준 등)
    성능
    테스트 통과
  

  리팩토링은 어떻게 하는가

    리팩토링과 기능 추가를 동시에 하지 말라
    충분한 테스트가 있는지 확인하고 자주 돌려보라
    단계별로 나누어서 신중히 작업하라



  테스트로 코딩하기

  테스트의 중요한 가치는 무엇일까?

  테스트는 버그를 찾기위함이 아니다.

  테스트를 일종의 첫 번째 사용자로 가정함으로써
  우리가 API를 추가할 때 메서드를 외부의 시선으로 보게 된다.

  과거에 출시 전 이해하지 못하고 작성한 함수들도 테스트코드를 통해 명확해진다.


  테스트의 이점이 많다 보니 아예 테스트를 먼저 작성하자고 주장하는 유파가 있다.
  TDD라는 기법을 사용하는데, 기본 주기는 다음과 같다.

    추가하고자 하는 작은 기능을 결정한다.
    그 기능이 통과하는 테스트를 작성한다.
    실패하는 코드를 작성하고 두 테스트가 모두 성공하도록 리팩토링 한다.

  처음 개발을 시작하는 사람들에게는 이점이 많지만
  TDD의 노예가 되는사람들을 보았다. 다음과 같은 징후로 찾아볼 수 있다.

    늘 100%의 커버리지 달성을 위해 많은 시간을 투자한다.
    많은 수의 중복 테스트가 생긴다.
    상향식으로 테스트코드를 작성한다.


  이를 방지하기 위해서는 목표가 어디인지 알아야한다.

  코끼리를 먹는 방법은 한 번에 한입씩이다.

  테스트 코드를 작성하다보면 테스트 통과 메시지에 홀려서 샛길로 빠지는 경우가 있다.


```
`23. 09. 08 금`
```
못읽었습니다
```
`23. 09. 13 수`
```
  속성 기반 테스트

  테스트를 given / when / then 방식으로 작성하더라도
  우리가 생각한 세가지 파트 결과가 모두 잘못될 수 있다.

  그런 문제를 해결할 방법 한 가지는 테스트할 코드와 테스트를 서로 다른사람이 작성하는것이다.

  우리는 그러나 이런방법을 선호하지 않고 그 대안으로 컴퓨터에게 테스트를 맡기기로 했다.

  속성 기반 테스트에는 계약, 불변식, 속성 이라는 것이 있다.

  이전 계약의 의한 설계에서 이야기한 코드가 지켜야 하는 요소를 계약이라 하고
  함수 실행 전후로 계속 참이 되는 조건을 불변식이라고 한다.

  예를들어 배열을 정렬했을 때, 배열의 길이는 항상 같다. 이런 상태를 불변식이라고 한다.

  이렇게 코드에 존재하는 계약과 불변식을 뭉뚱그려서 속성이라고 한다.
  그리고 속성을 찾아내서 테스트 자동화에 사용할 수 있는데, 이를 속성 기반 테스트라 한다.


  바깥에서는 안전에 주의하라

  우리는 주변애서 엄청난 데이터 유출과 해킹, 인터넷 사기등의 소식을 많이 접한다.

  대부분의 경우 공격자가 특출나거나 대단한 실력을 가진게 아니다.
  개발자가 부주의한 탓이다.

  기본 보안 규칙으로는
  1. 공격 표면을 최소화하라 : 코드의 복잡성이 높아지면 공격 표면이 넓어진다. 코드의 복잡성을 줄이고 입력, 출력받는 매개체를 최소화한다.

  2. 최소 권한 원칙 : 최소한의 권한만을 꼭 필요한 시간만큼만 제일 짧게 부여하라는 게 핵심 워칙이다. root나 Administrator같은 최고수준 권한을 사용하지 말라는 것이다.

  3. 안전한 기본값

  4. 민감 정보를 암호화하라

  5. 보안 업데이트를 적용하라
```
`23. 09. 15 금`
```
  이름짓기

  프로그래밍에서는 이름이 못든것이다.
  우리는 애플리케이션, 시스템, 모듈, 함수, 변수 등 모든것에 이름을 붙이고 의미를 부여한다.

  이름은 우리의 의도와 믿음을 잔뜩 드러내기 때문이다.

  컴퓨터 입문용 교재들에서는 변수 이름을 i, j, k등 한 글자 변수명을 절대 사용하지말라고 강조한다.

  사실 이는 프ㅗ그래밍 언어나 환경 문화에 달린것이다.
  자바나 C프로그래밍 진영에서는 반복문에서 증가하는 변수로 쓰여왔다.

  이런 환경에서 프로그래밍한다면 이런 코드와 맞닥트리게 될것이고, 이 관습을 어긴다면 틀린 것이 될 수 있다.

  한 가지 방법은 많은 의사소통을 장려하는 것이다.
  개발자들이 짝 프로그래밍을 하고 자주 짝을 바꾼다면 용어의 의미는 자연스럽게 퍼져나갈것이다.
```
`23. 09. 18 월`
```
  8장 프로젝트 전에

  요구 사항의 구렁텅이

  의뢰인과 개발자간의 요구사항에 대한 협상간에서
  개발자가 줄 수 있는 피드백이란 대부분 구두가 되겠지만 프로토타입이나 모형을 만들어 의뢰인에게 직접 디루어 볼 수 있도록 한다.

  이런 모형은 대게 한 시간 남짓이면 만들어 낼 수 있고 공들여 만들지 않아도 생각만 전달할 수 있으면 된다.


  불가능한 퍼즐 풀기

  중요한내용없음..
```
`23. 09. 19 화`
```
  함께일하기

  불가능하고 힘든 프로젝트를 성공적으로 완성하기 위해서는 함께 일하는게 필수이다.
  그 좋은 방식의 대표적인 두 가지는 짝 프로그래밍과 몹 프로그래밍이다.

  단순히 토론하고 메모하하는 것이 아니라, 실제로 코딩을 하는 와중에 질문을 하는것이다.

  짝프로그래밍

  짝프로그래밍은 익스트림 프로그래밍 실천 방식 중 하나였지만 별개로도 유명해졌다.

  짝프로그래밍은 개발자 두 명 중 한 명은 키보드를 조작하지만 다른 한 명은 하지 않는다.
  키보드 담당은 필요에 따라 바꿀 수 있고, 둘이 함께 문제를 푼다.

  큰 장점들은 사람들은 서로 다르기 때문에 다른 배경과 경험을 가지고 있고,
  문제를 해결하는데 있어서도 다른 접근방법을 사용한다.

  입력을 담당하느 개발자는 코딩 스타일이나 변수 명 같은 낮은 수준의 세부사항에 집중해야한다.

  다른 개발자는 더 높은 수준에서 넓은 범위를 보며 고민 할 수있다.

  몹 프로그래밍

  몹 짝프로그래밍이 둘이서 하는 거라면 몹 프로그래밍은 동시에 그 이상 셋 이상의 사람들이 참여하는 짝프로그래밍 확장판이다.

  결국 여럿이 머리를 맞대는 본질은 동일하고 주의해야할 점은 다음과 같다.

    누군가가 가장 똑똑한지 겨루는게 아니고 모두 각자 뛰어난 부분이 있다.
    소규모로 시작하라.
    코드를 비판하지 마라
    다른것이지 틀린게 아니다. 다른 사람의 관점을 듣고 이해하려 노력하라.
    자주 회고를 하라.


  애자일의 핵심

  애자일의 핵심 가치를 기억하자.

    공정과 도구보다 개인과 상호작용
    포괄적인 문서보다 작동하는 소프트웨어
    계약 협상보다 고객과의 협력
    계획을 따르기보다 변화에 대응하기



  9장 실용주의 프로젝트

  실용주의 팀

  개인이 실용주의를 따라도 이점이 있지만, 그 개인이 실용주의 팀에서 일한다면 그 이점은 몇 배로 커진다.

  실용주의 팀을 만드는 역학이나 측면들을 알아보자.


  깨진 창문을 없애라.

    아무리 부지런한 개발자라도 자질구레한 업무를 고치는데 오랜 열정을 쏟긴 힘들것이다.

  삶은 개구리

  냄비 속 개구리는 서서히 끓는 물에서 변화를 느끼지 못하고 결국 익어 죽을것이다.
  팀은 개인보다 더 삶은 개구리가 되기 쉽다.
  모두 변화를 감시하고 권장하라.


```
`23. 09. 20 수`
```
  실용주의 시작 도구

    버전관리
    회귀 테스트
    전체 자동화
  위 세 가지는 개발자를 위한 시작 도구를 지탱하는 핵심 도구로 모든 프로젝트의 기둥과도 같다.


  일찍 테스트하고, 자주, 자동으로 테스트 하라.

  코드를 작성하자마자 테스트해야한다.
  작은 잔챙이들은 꽤 빨리 자라나 거대한 상어가 되는 성질이 있다.
  상어가 잡는 일은 상당히 힘들다.


  단위테스트는 하나의 모듈을 테스트하는 코드다.

  부분으로 떼어 놓았을 때 제대로 작동하지 안흔ㄴ다면 합쳤을 때 역시 제대로 작동하지 않을것이다.
  다음 단계로 넘어가기 전 우리가 사용하는 모든 모듈의 단위테스트가 반드시 통과해야 한다.


  통합테스트는 프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는지 보여준다.
  통합테스트는 앞서 단위테스트의 확장에 지나지 않는다.

  성능 테스트 혹은 스트레스 테스트 역시 중요한 측면이다.
  소프트웨어가 실세계 조건의 성능이나 요구사항에 준수하는지 확인해볼 필요가 있다.


  전체 자동화
  모든 개발자가 동일한 IDE를 사용하는 어느 회사가 있다.
  회사 시스템 관리자가 IDE에 추가 패키지 설치하는 방법을 정리하여 개발자에게 배포했다.
  이 패키지에는 어딜 눌러라, 스크롤하라, 더블클릭하라 등 따위의 설명으로 가득 차 있었다.
  당연하게도 모든 개발자의 컴퓨터는 조금씩 다르고 동일한 코드여도 동작은 PC마다 미묘한 차이가 있었다.

  사람들은 컴퓨터처럼 같은일을 반복할 수 없을뿐더라 그것을 기대해서도 안된다.
  모든것이 자동화에 의존한다.
  빌드 전체가 자동화되어있지 않다면 클라우드 서버에서 프로젝트 빌드를 할 수 없을것이다/.
  
```
`23. 09. 23 목`
```
  오만과 편견

  어떤 개발자들은 프로젝트에서 코드 소유권이라는 발상 때문에 개발에 차질이 빚어질 수도 있다.
  사람들이 자신의 영토를 지키려 하듯 개발자들도 자신의 코드만 좋게 보고 동료들의 코드를 깎아내리는 편견으 갖고 있다.

  이는 우리가 원하는 바가 아니다. 다른 사람으로부터의 경계심 때문에 우리의 코드를 방어하려고 해서는 안된다.
  같은 맥락에서 다른 사람의 코드를 존중해야 한다.

  끝
```
